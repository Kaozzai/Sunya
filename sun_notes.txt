you can change the attack pattern on the fly
But you can also use the same pattern as many times as you want
or you can save prefabricated patterns as well?

i like the idea of expanding circles to announce attacks
color could define the type
there could be a type that makes no damage and only sends a proposition?

to strike the balance between a strategic  game and a fast paced, reaction skill based experience.

An interface to create instructions using memory strings on localStorage.
User should be able allocate previously saved instructions into an orb that satisfy conditions

sound waves, sound extractions, recorded sounds using vox, animations and their atached subevents

functions should be more independent in order for users to be able to customize any command available

orbs run animations with subevents attached


how radiance determines when and how animation windows appear
by asking all orbs involved for their needs, requests and conditions
>loop trough ml up , could be orb logic update, olup

maybe i can use the same architecture as stream system
Pushing animation windows >awin requested from olup

not sure if i want awin to be too tied with the inner mechanics.
The purpose of the awin mechanics is to organize the way actions ocurr, so it should be tied to inner mechanics i guess, bur i dont want to restrict too much the way events unfold

This is probly going to be a more personal mod..
i have to identify what kinds of window i could need first.
Maybe the size of the window could be related to the size of the object, but not necesarily always . sometimes we d want to see a detail from something big so a small window would be ok.

Window size should simply be calculated using the size of the animation to portray.

backed up so far*

ttttttiytyttiyiyiiuiiyytyyyupuuマケメ


✖✖✖⊗％██｟｠～｛｝▶＾＾＾＿＾＾＾＾＾＾＾＾＿＾＾｀｀｀．｀　＋＜５６７８４５＋＊＊＊２－（）＆］］＄？：：￦￦￦￦Ｕ￦Ｕ

To print animations over other animations in the correct order, awin should manipulate anim func array

wait, i havent realized this before?．．
I can just refference the orb on anim func.. why am i creating all these other objects?
logic should simply create a state object
refferencing the orb that influences it and push it into anim a

var orb = [ref orb ]　, then
orb.req =[anim index1, anim index2, ...]

.. not even that
The whole purpuse of anim func is to coordinate animations.
on ml up, orbs could arrange themselves in  order to be checked on acording to priority. the ..

ok so since loop goes backwards, obj[0]　will always be checked last. it makes sense that orb in control sits here because it can take all the data of other orbs and animate in correct order
All animations run for user on controled orb to see.

on logic loop, all orbs push a state with a refference to the animation they want to run into anim a.  but the last orb[0] rearranges anim a acordingly

backed up. .

i need to run tests to determine if the system making refferences is efficient or not

whats the cost of creating a refference?

new
Instead of creating rigid types, i could simply tag the attack, and the defense should have the same tag, to work as opposites
The concept of oposites is versatile, acts could have their oposites to prevent deals forcing themselves upon other orbs..

inflict. forces deals
prevent.  blocks forced deals
deal , key, lock, condition
link

Am trying to implement a system that is versatile enough to allow users to create their own mechanics as well

A contract is a special condition which allows orbs to compel to specified rules.
combat rules mostly



new stuff
When pattern is created, input listen to act with specific param value
.deal.listen.condition:param:attack
attack anim and now it modifies attack animation by adding a hit trigger time
.deal.onlisten.subevent.add:param:value
and a number to position on the sequence
.deal.onlisten.subevent.add:param:value

when pattern defense phase is called, we call circles using attacks new params values 
.link.circle
and input listen to defense commands
.deal.listen.condition:param:defense

A solid programing interface provides embeding options into animations

new
.deal.store or .asign or .newpv
Animations subevents create data for 
deals to be stored on other animations or orbs directly

.deal.use
We use stored values by refferencing them. 

.link
Links take references to call animations using thesenew stuff
When pattern is created, input listen to act with specific param value
.deal.listen.condition:param:attack
attack anim and now it modifies attack animation by adding a hit trigger time
.deal.onlisten.subevent.add:param:value
and a number to position on the sequence
.deal.onlisten.subevent.add:param:value

when pattern defense phase is called, we call circles using attacks new params values 
.link.circle
and input listen to defense commands
.deal.listen.condition:param:defense

A solid programing interface provides embeding options into animations

new
.deal.store or .asign or .newpv
Animations subevents create data for 
deals to be stored on other animations or orbs directly

.deal.use
We use stored values by refferencing them. 

.link
Links take references to call animations using these parameters

i think i l need an act editor after all..
 parameters

i think i l need an act editor after all..

We edit a png animation.
We edit a circle animation.
We edit a rect animation.
We edit text and streams.
..Streams?
where are png, circle and rect streams...? I need those !!!!!!!!
We edit acts using animations and text  and logic?

deals prpvide logic between acts
links use logic to call animations sequentially as required

タ
Acts link and run animations using input data from other orbs and conditions results.

オ
Acts can listen to other orbs acts and manipulate data to pass it on to other acts.

カ
All animations can be embeded deals so Acts can organize and use animations to create different events.

カ
Acts listen to other Acts and create independent logic using animations and orbs as parameter containers゚゚
storing permanent or temporary data

better yet
We use .deals to substract and asign data in between animations .  
Not sure if users should be able to directly create new orb parameters ..サ
ｂｕｔ　no more attack＜＞defense 
ting

.if.link:target:param:value:animation



￢＿￢

Should we be able to save attack patterns on localstorage?
sound snipet, miscelaneous data, vox record, animation seq, text, circle anim, rect anim

we should be able to store instructions on how we want a sound file to run. maybe a specific part to be run on loop when a specific act calls it etc

Animation logic can also be stored.
All deals data goes into a single animation param?
would be  simpler than adding param value pair into each frame...?
All kinds of instructions to manipulate animations should be able to be stored.
because instructions can be synthetized into a string from elements inside an array.

a pattern is a result obtained from the interaction between two acts.
pattern creator and attacks.
a pattern is a list of names, queues, and a tag  to tell recaller how to use and where to store it
The act that uses patterns is rythmic invasive phase, where defender gets to defend using Defend anims or take hits. once the outcome is secured, animations run acordingly. a showdown.

create pattern
pattern sent
defensive phase
resolution
............
1 png per orb makes sense but
1 sound file per orb doesnt sound right..

Do orbs mem vessel have location..?
Does user have location when on void．．?

Location and perception are radiant plane conditions.
On radiance contract, orb will now have location and perception parameters. So now to perform upon other orbs on radiance, the perception condition should be fullfilled, and acts with a specified parameter .displace:value will now be able to update location acordingly

Radiant plane needs to be a connecting entity... maybe it simply has to be an orb running a specific logic. Such orb would act as a scene orb. To grant other orbs a position , it needs to stablish a contract with such orb.
max number of orbs, combat rules, and  all interacting conditions are all set up by scene orbs contracts.

Scene is a special act performed by an orb. the scene act accepts contracts with other orbs. On deal, it begins to listen to all orbs contracted.
Everytime contracted orbs perform on scene, we use data on scene orb to determine results.

condition types!
A contract is a condition.
It may run on the orb contractor itself or on another orb.

1 on frame, simply add param value pair
on self(orb casting animation)．　no condition
We can use this deal to displace orbs.

While on edit mode, user must have a frame selected and enter a command,
.intersect
Now when another animation linked has the .intersect event asigned, we calculate >>　next animation entrance point using the .intersect frame as reference. its part of  .link deal mechanism

2 triggers if orb param equals specified value
3  a counter
Another event can add to the counter per proc, or a counter can simply add on loop frame

4 orb will listen to specific events as long as the act is being performed
. This is how we create attack patterns and this is how we create Scene orbs

Acts could be written on text editor..
So at any moment orbs can call acts using .run

Acts may have ,
a run condition
an ending condition
a  listening condition
a link condition
an influence condition
a memory array to store custom values to create independent logic

backed up so far

Act texts use keywords
The act editor has access to all data from orbs and users. it is up to the creator to make balanced rules for users and orbs to interact. A deal can prevent users from creating acts that would break the 'game' once the deal is contracted.
Deals also provide information that would not be available if the deal wasnt contracted.


act > 'act'　on first line to read text as an act
.link.png:[name] > Links animation. can take a .connect to specify a point of interaction
listen >　listen to orbs that cast acts carrying a specific parameter. can be local or global
.deal >　adds parameters into orbs or into animations.
.create >　creates an act using data obtained from a .listen

backed up

pattern combat phase should call animation acts instead of animations directly because acts hold data on how the animation should behave
In this way, acts can call more than 1　animation to compose a new animation with graphics, sound, and other effects.
act editing should be able to control the flow of animations involved. a symbol to separate statements?
.link.png:'name'>>.intersect.frame:'value'>>.deal.param:'value'
.intersect could take frame, time , positionxy?.. maybe i should just use .deals.. .deal:'param':'value'
All animations should be able to tell exactly how the next animation should be placed and run respectively.


am using translate now to let draw functions take parameters from deals
.link should be able to alter animations position , start, end time and context using deals.
also remember to modify array storage for different types of animations, its not elegant to have all animations thrown into the same array



new stuff
／stream［target orb]［text]
we should be able to call streams from here as well.. maybe i could return a stream tag to work with it later..
we could use ／mainstream if we want to send text into the default log and let ／stream be the target orb custom com channel stream

／on［listened act tag]>>［a returned edit access]／／x［new value]
the／on macro should also be able work with returned tags directly and not just macros

maybe the  on macros could ask if a returned tag has a certain value, and do something in such case.
／on［returned tag]=［value]>>　．．


arrow synthax for ／on macro looks ok i guess

instead of ／on.. it could be ／if

we could do math ops like this:
／if［returned tag]-［some other value]>> .. any statement
)(()()()()()()()()
<>　．．　we could use these instead of >>

backed up

once linked , an edit tag allows temporary specifications to be accesed and modified, these are then used by a created state to run.
png:
ctx, loop, globalX, globalY, global alpha,
name

backed up

chess.com

touch screen need only to ask if touch is in selectable area and run an available interaction. this is pretty straightforward.
i might implement gestures to access subcommands

a cross , a command to adjust that cross, and a rectangle around the cross to delimit the animation. size of limit rect should also be adjustable.
interaction cross. rect limit anim.
moving the cross also moves the limit rect. 
we can now position the cross on the screen to determine where the interaction is going to take place.

we use interaction cross and interaction frame on acts to connect with other animations in a meaningful way.
Acts will now be able to use this data to organize events.

.. instead of a new state to mess around with, the interaction cross should simply
be the x0　y0 point in screen, but now editor should be able to move around this point using translate().
png edit will normally position it in the center of the screen so we can easily create the animation using image coordinates, but then, act can translate canvas to run the animation on a desired position
backed up

It is also convenient to manage negative values on the grid since there are other canvas methods that can benefit from this aproach
canvas.scale(-x, y) is able to flip canvas images horizontally.
We can also flip vertically using negative y values.

I cant really tell at which point translate restores canvas to the original position tho... ou maybe canvas resizing is doing that. but i dont really need to since am incorporating translate control to drawing states functions directly so canvas gets restored everytime. not sure if this might be too expensive.. but i  think its ok.
I still need to add flip mechanic

acts need to be checked before anim func?
since acts themselves are neutral when interact with each other, maybe they need to be checked from outside orbs ml up..
1　on first instance ,we should first check orb acts for exposed deals . make an array of all deals storing access to casting orbs.

2　then, a different instance checks for listeners, modifiers and act logic in general so it can determine results with all deals exposed at hand, without having to loop trough all orbs again.
Uncontrolled orbs should not even ask if edit mode is on... 

3　last instance uses deals results and states effects that concern users current stance to paint the final picture on screen. probly should be done by controled orb. such orb would need to be positioned on index 0 from up obj to have the final word on results.





.run calls for 
actuator() reads the script for the act and creates  exposed
an object to be pushed into act d
ready to be updated on
c act d() controls the act flow

an act can run for a time, or it can run until a condition is met.

act d[0], [1], etc are acts.

act.deals , links, listeners, d tags, e tags, conditions, streams. arrays to hold programs
deals[0], [1], etc are different deals and so on..



new stuff
at every update
c act d loops trough act d, and asks for 
listeners.
using listeners, we check deals exposed and gain access to acts exposing these.
We now check for statements, and run those that have tags to which we have access only.

statements and locked statements have the same structure but we need to have access to keys to run them.
in order to have a specific key access, actors must be accessible and the condition on the statement must be fullfilled. so keys are similar to tags but they are used specifically as conditions to run the statements.

ready to read statements are arrays whose elements are each a single string.
every pair of consecutive string represents an instruction and a value to work with.
we loop trough every element.

tag needs to know if we have access to the actor using value pair as access word. if we dont have access, then the rest of the statament is ignored.

command will perform a diferent function depending on its value pair. its value is the explicit word for the command itself.

operator sets up the statement into 2 operands and works with them. also returns true or false to a condition if there is one

parameters work with commands acordingly
backed upサササササササササササア

new stufミ

am having an existencial dilema with ml up now.

ok so What do we really need to update.. acts
Because edit modes just need to check user in contrl orb... should also check for the final graphics results.
But all orbs need their running acts to be checked . however some of these orbs will cast animations that users should not always run on screen..
maybe i need to implement dummy timers for such animations..

while other users are on a shared session, orbs may leak tiny fragments of image data for users who d like to peak into orbs activity. while glading above the orb vessel area they might be able to see shadows and difuminated figures constructed from these fragments.

orbs take the form of a circle on screen. they vary in size acording to their data quantity. users can glide trough the void to see orbs vessels.
orbs are mostly black but their perimeter glows in multiple colours.

we can also add words into deals value?
that sounds interesting


ok so instead of linearly annalize each element on statements we create a function to work with one actor at a time and then run this function as many times as there are actors.
function takes the actor and its intent and
returns a var to indicate what to run next
or an array of actors returned values to do math with them and an indicator var to tell whats next
backed


deals can be listened, when listened, they provide actors. actors can provide animations and data.

a memory line editor. paste animation instructions into an input box straight from a copied text.
reveal a text line containing animation instructions on a text box for users to copy and paste freely.
use .txt files to save and load orbs memories.acts, animations, texts, anything that can be created.

modify input so its able to accept multiple lines at once. each line a diferent animation to be reconstructed
Now many animations can be loaded at once, so a single .txt file can contain all memories of a single orb

maybe just shift controled orb acts and push other orbs acts

ml up doesnt make sense now.

whats wrong with param value affecting actors?
make all values be numbers? 
we can simply use container element to locate and use always as a string
and let value be always a number

stupid fucking energy scarcity



new stuff
so math on act scripts is nice but sometimes i just want to set a specific edit parameter to a certain value directly

touch will interact with animations so the most direct method would be to implement a function to compare touch coordinates with states coordinates.

touching the void should call up basic orb management button for commands
.create Focus on input now to let user type in the name of the new orb

When an orb is created, it will now sit in the background. Touching the orb prim will call new buttons and also will print data about the orb.
.control Allows user to change stance to orb.in
.list Macro will list .png, .txt, .circle, .rect, .osc, .audio, .act, and so on
.act We can call up acts available from here as well.

edit using touches wil be a thing on itself

once we r orb.in, we can touch the background to call editors buttons
We need animations to enrich the interface, letting know users each touch has an effect.

A button for each type of editor.
a .list button to ask which type of edits user wishes to list
upload image and upload sound button.

We can always touch background again to hide buttons

touching an edit button will focus on input for user to type in a new or existing edit to work on.

Edit modes can use 2 touches and sliding one touch to adjust parameters.

Buttons to select next or previous frames.

on png edit mode, we could adjust the size and position of the selection rect using cursor buttons.

i need to verify if i can cancel the swipe down default action to actualize page on phone browsers , this is very annoying and renders swipes useless.
backed

new stuff
just implement a gesture to call input box for now.




a command to center the cursor. done
tt touch time to measure how long touch is, call a different com on long press. done
buttons and text could all share ctx3 but i just need to secure stream clears first followed
by buttons being redrawn.. this might be too expensive. maybe just create a ctx4 exclusively
for buttons.
each button memory should have a persist value . done
implement a blink mode on buttons and interface texts so color doesnt fade into bg
a gesture to slide scroll default stream and other streams maybe
a gesture to swipe down and up on any stance bg to call input box. done


we should be able to save other things besides edits
json implementing. make copy text touchable. done

update orbs key_s on key mem system no longer exists done
.consolidate A command to remove all edit tools from an orb and only keep edits
.tools A command to call back edit tools into an orb again

we could just send a .signal into the current mode to call exit. exit here doesnt
look gr3at done


a system to keep track of every used name . every object with a name should be available
for json management.
an op to remove a name when requested
implementing unl system... maybe?

make a long press on any bg to call i.put box. it a great gesture

a gesture to  lock all screen interactions?

a large swipe left to change oscillator on box

prims should reflect how many edits, different hallo s size and color
rect and different shapes all around
prims can offer deals with gestures
we should be able to rename orbs
and destroy them. .
a centered cross pulsing slowly for edit modes
letters changing colors slow and fast
inner bg pulses slowly add random

an animation shkws 3 optionseach option changi.g a parameter on an animation

implement joystick on txt mode.. and other modes
a command to asign same time into all frames. done

the idea of trimming orbs , removing edit tools and just leavi.g alo.e the purpose 
of the vessel sailing North. 
orb.name.consolidate .. commit ? i have to build all edit tools buttons yet
To get back all default tools, a consolidated vessel can absorb a new orb to recall
memory management tools once again.

or maybe..
access any edit and mark to lock
.png.[name].lock
now when we .orb.[name].purge , all default data of the orb is removed and only previously
locked edits remain.. i kinda like this

an option to fuse orbs..?
All data from both orbs is kept.

fix audio editor.. then go for vox implementation on act language..
system logic has been reframed, we are keeping vox

fix .png anim name ting done
i cant fix this godamn thing holy fucking shit ok i did it, its fixed
i was recalling a corrupted png memory with an empty array with json import system..
thats why i had a hard time debugging
ErrorEvent.message
ErrorEvent.lineno

javascript:(function () { var script = document.createElement('script'); script.src="https://cdn.jsdelivr.net/npm/eruda"; document.body.append(script); script.onload = function () { eruda.init(); } })();

so when command is run,
.scan
it deactivates touch listeners and when NS() iscalled
from console, it normalizes all . done


3 main entities to help you on tutorial journey
edi ting teacher, s crip t master , terminal onliner

inner mode could accept a signal to stop random color pulsing on bg..

users should be able to swap between orbs faster normally

vox needs to handle k buttons differently on 2 touches. done


orb.in  | radiance
While orbs are on orb.in we can access to edit modes trough specific commands
We can also access radiant mode from here.
radiant mode has a single command available .run, we use run to create acts using scripts
.run:[act name]
radiant orbs can make deals and listen to other deals
scripts are created on txt editor using a specific sinthax, the act language
While in radiance, orbs have diferent conditions to be accessed to.
an orb may run its own AI in radiant mode.
once on radiance, a special condition must be met in order to go back to inner mode
1 orb must not be linked to any other orb trough scripts


i need randomizer value asigner on edits, change the value at every run
.. edits are suposed to let you edit in a precise way. randomizer doesnt seem to fit
very well..
i need a tag to asign selected value to every frame at once(including randomizer)..noup
i needthe cross in middle for refference
it would be nice to also improve performance
and also we should be able to asign animations into transitions without act language..
.. transitions... hmm
.circle.[name]...



//..the rec logic
/*
//to start it
						//i need an id to avoid problems here
						var id = all.au.currentTime;//id should be stored on a_a for later access.. ?
						//to prevent too fast keydown, use previous timestamp and add some time
						if(a_a.on_a[0]){var fast = true;}
						if(fast){if(a_a.on_a[0]+0.3>id){var dont = true;}}
						if(dont){//dont push another sound please, its too fast
						}else{
							var a_s = all.find_ting(all.anim_a, "name", a_a.name+"_"+a_a.on_a[0]);
							if(a_s){var ask_loop = true;}
							if(ask_loop){if(a_s.loop){var loop = true;}}		
							
							if(loop){
								all.stream_a.push("Key already on loop"); all.screen_log();
								//console.log("Key already on loop");
							}else{
								//record system
								if(o.rec[0] !== "off"){
								var starttime = id-o.rec[1];
								o.rec.push(a_a.name+"_start_"+starttime+"_"+id);
								}//
								a_a.on_a.push(id);//default
								var a_s = all.osc_s(all.au, a_a.name+"_"+id, a_a);
								a_s.gain_n.gain.value= 0.001; 
								a_s.gain_n.gain.setTargetAtTime(a_a.gain, all.au.currentTime, 0.06);
								all.anim_a.push(a_s);
								//record
								//here goes visual
	
//////to end it
	if(check_vox){
		var a_a = all.find_ting(c_o.osc, "asigned_key", k);
		if(a_a){
			var id = a_a.on_a[0];//
			if(id){
				var a_s = all.find_ting(all.anim_a , "name", a_a.name+"_"+id);
				if(a_s){
					if(a_s.loop==true){//dont let keyup end it
					
					}else{ 
						a_s.end="fade"; //default..
						if(c_o.rec[0] !== "off"){//if rec on then..
							var endtime = all.au.currentTime-c_o.rec[1];
							c_o.rec.push(a_a.name+"_end_"+endtime+"_"+id);
						}
						var silence = a_a.on_a.splice(0,1);
						console.log("silence "+silence);	
					}
				}
			}//check id of previus state of same osc
		}//if key is asigned to osc
	}//check vox
	
	
	
	
*/


transition animations ... mostly done
transitions are requested using commands and managed during init phase
states to create all transitions.
obg , a circle on ctx0 flashing with colors which can expand , compress or idle . __obg
lid , a rect on ctx3 opaque and black which can open and close orbs radiant eye . __lid
prims , created using orbs data, can only be seen from void stance. orbname_prim00 ,
orbname_prim01 ...

.orb.[name].control , if orb is on inner mode , void to inner. push obg se expand
color circle expand into pulsing colors. 
selected prim is copied on obg, all prims are removed, obg expand to fill screen,
obg runs idle on end

.orb.[name].control , if orb is on radiant mode  , void to radiant. push obg se expand
with colors, and fade out. on end remove obg

.perform , inner to radiant , push lid se open, obg runs fastcolors
black line horizontal, like an openning eye . remove both on end

.reform ,  radiant to inner . push obg se fastcolors, lid se close
periphery up and down closing into midline, like closing an eye
on lid end, obg runs idle , and remove lid

.signal.op3:exit , inner to void . obg run compress
on end, run user void init to handle prims , and remove obg
color circle shrinking into prim size

.signal.op3:exit ,  radiant to void . push obg fastcolors_compress
remove obg on end, run user void init to handle prims . 

.orb:[new orb name] , orb birth animation . push obg se brings
on end void handle new prim, remove obg

.orb.[name].forget  , orb death animation . push obg se death



Not only k should be fast responsive, we need as many multi touches as posible, and
we want to asign snipets of audio along with oscillators as well.
We should be able to asign snipets from different audios into the same vox session.
A double swipe outwards to inmediately open editor for the asigned audio on k would
be neat
..Maybe on radiant mode...
Also swipes on specific direction to lock in the touch.
7297 tstart k event handler
7931 k bt processor
7712 a fast attempt
8241 k on c_tch

4032 edit txt mode
4314 getting there
...what about s.s parameter.. i think we can keep that

1528 anim audio
3655 edit audio
6291 .audio
7156 buffer state
708 audio handler

5085 rainbow rect sel on png edit
5486 same as above
8514 orb escence on update
64 orb escence defined
891 six rainbow
3851 rainbow interface on audio

connect orbs from void with a gesture ?
to enable audio for user. multiple orbs can connect so user on void can listen to all?

make Tools default orb already

A free fight mod where a maximum fighting capacity is distributed among a team of
figthers. Users distribute strengths and weaknesses to create the strongest team.
There is a defense team and an offense team.

2207 runa()
3227 runa on radiance
7309 .play command


2280 png on runa
1679 png on anim f
1739 u_state png

5307 png init bg
1276 png img state creator
5568 capture
5423 cursor png
1805 u_rect anim f
5500 u_rect width height
4807 am here
7663 new scroll done


7962 scroll img swipe tch
1999 anim cue system

7461 text on button
8298 tch button swipe
1708 txt state on anim f
8407 bt clear
946 logger se ctx3

5046 cross on edit png mode
1616 ctx3 redraw management
8104 scroll img tch system
5059 init edit png

5636 png feed

867 screen log

8508 update
5586 interface png edit
915 logger ctx2 doubts
5611 up d_c
5648 e png feedback
5251 e png w h
1748 txt anim f update

8464 remove the bt_txt


stream retrospective
void
When user is on void, type in goes to mainstream or command processing.
Only void entities can see mainstream lines, users are void entities.
When more than one user is connected to a server, mainstream becomes a public
channel.
on void, input goes to mainstream
Mainstream behaves exactly the same when users are in control of orbs while
on inner mode. In this way users can work on animations or scripts while
being able to chat and share text lines on mainstream channel at any moment.
radiant mode
When user is on orb radiant mode, type in goes to radiant stream or com proc.
input text on radiant stream becomes a script element which can interact with other
radiant orbs. we now use the orb own customized stream.
A single rad orb can listen to multiple streams from other rad orbs using a
script. If users are in control of radiants, then the stream does not print
messages from mainstream anymore.
Should we simply have one stream? .. am thinking yes. just one solid stream
responsive to all modes and stances
remove sixlines completely, just use a special animation for edit interface
words?
1 mainstream for user, and 1 stream for each orb.
customized streams redraw at every beat because they all use ctx3. this is how
we avoid funky clears 
 
the timer on animations will probly need structural change because another
animation in proxmity on same ctx may mess draw with its clears. so if a frame
wants a longer duration its fine, but we probly should just clear and draw at
every beat anyway... but this is.. insane i have to build the whole 5jing again



online
The amount of users is determined by server rules.
radiant orbs can run resource acts which are available to other radiant orbs.
If radiant orb running these resources is online, resources are then available
for radiant orbs from other users online.


I would like to have a single html file to contain js and css as well but it
does mess up most editors legibility


6048 the .help command
7251 help
7275

6343
419
3132 The funky signal exit on inner mode.
3090 needs to go
6572 .void

7144
6036 .help
6104 
6199
exit, gain_+-, start time_+-, end time_+-, hz up_123, hz down_123
sine, square, saw, triangle, next, back, e, size_+-, r_123, g_123, b_123, a_+-,
change, remove, left_123, right_123, up_123, down_123, sleft_123, sright_123,
sup_123, sdown_123, width_+-, height_+-, center,
empty, filled, radius_+-, define, capture, run, alltime_123, time_123,

6499
6410
5992
6426
3066 inner idle
2988 inner init
3105 obgr animate
3146 removing obgr

6410 print mbt
6306 next help
4045
6555 .mainstream sup
3739 all.screen_log sixlines on audio edit
823 all.screen_log func
508 arrows stream scroll
897 the new logger
902 screen log arrows ting
5096
5706 img edit feed
1014
`rgba(${s.r},${s.g},${s.b},${s.a})`;
we need to update feed stream on all other edit modes, only img ready so far
3169 empty rect animation bg on inner mode
5337
1267
7003
6653
9170
7479
4969
7484
1871
7403
ok rect and circle ready, while running on inner mode circle erases. its
because i need to fix the time thing. i want to print all animations on same
ctx at every beat so they can work togheter and not clear wrongly

7076 img run on inner mode
1628 c_img on anim_func
5421 run test on img editor
5058 img editor exit
img run on inner mode done..
ok so now we need tags to let know all orb modes which edit is being used.
every time user strats inner mode, we want to ask what edits should be already
running.
every time we enter radiant mode, we already should be inmersed in scripts
effects.
we cant just ask what states are up because we want to remove all states when
we go from mode to mode , orb to orb etc.
2888 inner init pushing running animations
3080 removing inner mode running states when going to void
4256 removing inner mode running states when going to editor
4292 edit circle exit
so far circle editor is doing the ting... keep going .. you need to do rect,
img, txt, osc, audio..
then i think we could continue with act scripting. you got this
2910
7238 
problem
7698 rect:new
3000 the problem is here
1811 and here rect func
5070 rect run sim
7149 .img
7298 .txt

4174 txt editor new func?
4228 txt editor print best print
7464 .txt.run
1605 txt on animf
2917 txt on inner
1627 custom txt using u_state
7558
ok so we are good with img, txt, rect, and circle for now
lets make feedbacks on edit modes better and also work a bit on void
animations.
6017
5998
4283 custom on txt edit
7524
4464 edit txt feedback
x property change needs to be revised, consider custom display with a single
item to be  default instead of 'normal'
5058 a on edit rect

ok lets work on act scripts now . its been a while i dont want it to get too
rusty
7974 perform command from inner mode.
8008 reform commands from radiant mode
8109 play command act found
2004 actuator function
2344 runa function
2555 img state push with act script
7411 img state push with run command
2602 stream on act script
so we want to b able to print other orbs streams on our screen while on
radiant mode..? or we want to see our streams printing messages from other
orbs streams?.. yeah more like that.. we want actors to listen to our streams
input and process them so in order to do that, we need to play resource acts
to broadcast our stream and make it accessible for other orbs or actors
When we see a resource script we should be able to run the script txt to see
it, get the name of the orb playing it and access its stream
..ok so i slept on it and this is what i want:
we will be able to store a radiant orb stream value into a logic container
inside a target resource
actors will have access to their own stream trough an instruction. //stream

okok so resource objects now will have a new instruction to allow orbs to
share their stream data(including stream history) so actors can create access
tags to work with any stream available.. yes.
[stream access tag]//print  ,  x , y , limit , size ... all properties from a
stream are accessible?.. no maybe later

okoko we need
1 a stream object for radiant mode
2 a stream instruction to make the stream from orb sharing resource available
3 instructions to process stream text from actors
its done

2224 ahhh /end on actuator
4358
2551 end on playa
1722 run img on animf
2637 txt lks on phase 2
1636 txt on animf
2862 placing result on phase 2


we need a way to clone a txt edit. would be convenient to write scripts..
maybe unnecesary..

we also need to be able to change edits names... txt is ready

maybe we do want literals on phase 2.... do we

custom_a could also rememeber changes for specific lines. would be useful to
have that on txt editor

consider making tags and conditions be written once instead of having to add
them at every line when we want to make multiple changes to the same tag or
lock multiple statements using the same condition or condition
{}some statement
some statement
some statement


ok so radiance has a bunch of details to polish. . first thing is orbs streams
while on radiance are manageable from scripts, we can use streamlines to
interact with animations. orb streams have their own history inside.
So we probly need a way to handle history removal. mainstream history already
can be cleansed using the .mainstream.clear command, but orb streams also
need a way to clear their history right? but it feels weird to just make a
command becaus orbs streams will work with scripts. . or maybe yes we need a
stream.clear... but maybe it can be controled from outside... so its a void
command. This would kinda make sense since clearing history of orbs is like
erasing its memory on the radiant plane. command would be;
.orb.nameoforb.history.forget
Would be interesting to be able to actually print an orb history on
mainstream:
.orb.nameoforb.history


ok so i i think i figured out how this should be..
Orb on inner mode cant run acts. It takes being on radiant mode to run acts.
So users need to be able to take control of orbs on radiant mode as well as
inner mode orbs. When a radiant orb reforms, all actors should stop working.
We should be able leave from a radiant orb and go into the void while an orb
just keeps performing. So while on void, we should be able to make an orb start
performing without having to take control of it. And also run acts.  

about commands
thinking about command synthax . maybe it would make more sense to do
.orb.nameofexistantorb to edit instead of .orb:existantorb becase, ":" are
suposed to be reserved to enter new data. Its more consistent this way

So from void, we can do:
.orb.nameoforb.perform
So now this orb will start performing
We can also do:
.orb.nameoforb.reform
To make the orb stop performing.
Only an orb in radiant mode(performing) can execute acts.
We can command a radiant orb to play an act, but it will only work with orbs on
radiant mode.
.orb.nameoforb.nameofact.play
....
this is interesting... because it makes sense to do this from void stance and
also gives it a different perspective
...
So what if we could do:
.orb.nameoforb.nameofact ... this could print the script of the act on
mainstream... that l be interesting
Or we could do:
.orb.nameoforb.stream.5 ... So it prints lets say 5 lines of that orb history
on mainstream
So it comes,
.orb.nameoforb.img  , txt , rect, circle , osc ... so its possible to call
oscillators to run in the void. yeah thats awesome i want that >3
These 2 particular edits, osc and audio can be listened from a user on the
void.
.orb.nameoforb.osc.nameofosc.run .. 
.orb.nameoforb.audio.nameofaudio.run .. 

Does all this feed your mind?

kaiashtirum
Stay still until your body cries out. Then focus on how incredible breathing
is.
Maybe you can polarize your body like this.
trataka
Candle staring.


The idea of making commands able to create links between all planes.


When user is not on radiant plane, animations from radiant plane dont paint on
screen? but they are still existing. so all statements are running, logic
containers are changing their values and so on
.. how to run all operations that involve link states but without states
drawing all over a user screen that is not in control or an orb on radiant
plane >>> s.offs = true  . this does the trick

also we need to remove resources if orb is reforming. //done

animations of primordial forms
While on void, users get to see how orbs express what they are doing using
colors and different animations.
I DOnt like the obg and obgr system so far, i think its confusing to keep
track.. this needs revision

Just go into circle and rect editor, create these animations and store them on
user box. It does make sense that user box could do that after all?
Should these animations actually be acts running.. ? maybe not.. but just
hardcored instructions to call specifically named animations.
Users can later mess with animations perhaps?
Or maybe these could just be default prim animations stored in orbs.
Anyways, first we need to remove all the funky stuff from intermissions, just
let the program work perfectly without any prim animation and start working
from there


//these are kinda deprecated
orb creation
A circle state and a rect state should be able to handle the most basic orb
creation animation. fade in multicolours full screen and quick fade out and
quick compress into an empty circle . no more
Creating an orb(vessel soul) now involves forming a husk and then giving it a
name.

orb idling on void
Multi colored empty cirle, size varying depending on animations stored, maybe
add more layers of colours depending on mode the orb is

orb memory vanish
This one needs a cool effect with all the words maybe but for now just
slowly fade out all words floating inside or something

orb destruction
Glass shattering and slowing moving down to illustrate the nature of a sinking
vessel. Orbs are indeed just like bubbles floating in the sea.

void to inner mode
Primordial selected starts growing until all screen is covered, fills and fade
in all screen in orb escense, and while fading out, all screen borders are now orb
escence

inner mode to void
Fade in filled with orb escense full screen into circle prim idle.

void to radiant mode
Selectred circle expanding filled with orb escense, fill screen and fade out.

radiant mode to void
Fade in filled with orb escense full screen into circle prim idle.

inner mode to radiant mode
Full screen in orb escense , eye lid opens up

radiant mode to inner mode
Full screen in orb escense , eye lid closing down




..... .................................................................... on
the other hand..

Ok so now what i really need to solve is, how are these waves going to
interact with each other without having a script. SHould we just use se
subevents again? that might be viable..

Just make commands create states to work with..

ok so how will radials work:
we need coordinates. vx vy need to be added to x and y to calculate user
position. vx and vy should always just locate the screen center of a user?
so all void states should have this coordinate added into x and y
its the void node limit. so we have a grid
all.voidnode.limitx , limity , pressure , heat?
To calculate the position of any state on a void node, we simply add user
position into all calculation.?
Maybe we could displace trough void using a grid.
The size of the screen determines a block, we can move from block to block to
reach our destination. .. maybe
So radials will need x , y , orix, oriy , 
.. Ok so i think the simplest thing is to just use x and y as is and let user
coordinates pass on inverse translate values.
We just tx=-ux and ty=-uy . this works !!!!!

ok we can make more than one impulse at a time.. but there is a limit. if you
go beyond this limit, user starts to loose its memories. maybe strong
heartbeat can acompany excess of impulse casting..

How does an orb size affect its parameters.. maybe its maximum animation
caps.. or its hability to create scripts.. or its hit points.. what if we
create an orb inside another orb..

thinking about the limit of the grid.. what is it really and how should it
react to user activity. I dont want a stupid meaningles invisible wall >:{

gotta refresh my knowledge on canvas methods..
beginPath()
strokeStyle = "blue"
moveTo(x,y)
lineTo(x,y)
stroke() 
etc...

arc(x, y, radius, startAngle, endAngle)
arc(x, y, radius, startAngle, endAngle, counterclockwise)

we can build a path?
var path1 = new Path2D()
path1.moveTo(...)...
And the we can ask if a point is on path

isPointInPath(x, y)
isPointInPath(x, y, fillRule)
isPointInPath(path, x, y)
isPointInPath(path, x, y, fillRule)
yeah i can use this to mess around with waves

need a command to out user object.. kinda done

its great when we print a lot of stuff and just dont clear. chaos mode . great
.kaoz mode
idea

so maybe orb size determines canvas size.. thats interesting..

the boundaries of a void node need to be delightful and delicate designs
adorning it. ancient

simply enlarge the vessels we control so the rainbow light is round and always
visible on the border.

impulse mechanics could have an option to print some feedback with numbers

init is always a tag for user to change its environment
void stance, orb stance, all modes... they all call init... should modes
simply be stance?.. we do want to leave an orb on radiant mode while away BUT
we dont want to leave an orb.. on edit mode? wait.. why not

displace command needs to be kinda universal... done .. kinda

husks are not suposed to have memory , but right now am just accessing user
mbox while on husk stance

we can use scripts to modify the screen size

husks dust acumulating down. a tree start to emerge from it.

i think we need custom display for circles and rects. its way easier and faster
to do stuff

tx and ty need more thinking. right now its not compatible with void waves
system

just forget about translate. all we need is x y, and window.scrollX ,
window.scrollY

all.stream_clear is doing something weird , a funky clear.. fixed
and also fixed the delayed txt clear. now txt states have sx and sy which
informs the operation about scroll position at the time the state was printed
so we can clear txt just fine

ok so now the .orb.name of orb.control will look for a vessel and issue a
command.... yeah we should be able to issue commands to our vessels directly
once we name them.

so impulses carry commands and we use them on void to send commands to vessels
and create constructive effects on void forms

we can use radial pulses to create opossite from impulses kinds of effects

yeah we should always asign a location on window scroll to every void prim

Simply using sub events se , we can control the flow of states perfectly

dont even bother testing this. You need to get this thing straight, go clarify
the structure of what can and cant be before you keep changing things around,
or you will get lost and discouraged. dont let that happen , stay focused.


user stance is merely an indicator of what should we print on screen.

on void stance,
user can see a section of the void sea determined by the machine
screen size and x and y coordinates so we need to check for states, its a loop
on anim_a.

impulses which have user signature once reaching a husk can change user stance
into husk stance

all states should always be checked anyway. we just need to know what should
be rendered at user screen, user stance tells us that.

The problem with big canvas element is that it consumes too much resources....
or maybe i have too many big canvases... maybe one big canvas may run just
fine.
Make all vibe. Just one canvas for eveything

wow... i havent noticed canvas does computations beyond its size... cool. this
solves my problem.
But what about images, i rememeber i had a problem where big images didnt
render completely when canvas size was too small

orbs are extensions of user s souls
orbs have memories
memories contain instructions to create states
users cast commands to create states
states have tags and follow rules
users stance determine what to print

when pressure on void node is negative, background has a glowing blue
when pressure on void node is positive, bg has a red glow

we orbs to handle their vessels data.

i just realized we cant use the same state to print what happens when user
goes into a husk or an orb because that state still needs to print how
everything looks from the void. we need to create a new state to enhance user
experience inside a vessel or a husk while leaving the prims to its thing
without drawing
anim_a loop basically should just check everything in one loop.
waves, vessels, husks, .. states need to hold tags to link void entities data.
A link to the user controling the state, or a link to the orb controling that
state. Orbs are linked to the user soul that named the vessel

ok so
void stance requires:
- using translate to print black sea acording to user position.
- unlocking access to user membox to hold personalized keys with commands
- making specific void commands available

orb stance requires:
-create one or more states to animate orb vessel from inside. the radius
surrounding the user, the lid curtain to illustrate perform and reform etc
-unlocking access to orb membox
-and making editors commands available for user.

husk stance requires:
-create one or more states to animate husk from inside.
-we should not be able to access a memory on husks
-we should be able to move a bit to see the husk circle limits.

Instead of an init tag, we need an instance for Transitions
We always need a rect state to have control over fade in and out colours to
smooth transition changes. A rect to take the color and the alpha we need on
full screen whenever required. We always need this one to be ready.
Maybe 2 rects. elid1 and elid2 and circle , pupil. Its the user eye
I just noticed, there is no user on void init now.. ok let me think
transition requires control over eye elements and stance. its good to call
init on modes because we can also work with each mode init states , but when
we go to void, there is no init there. Maybe we do need a void_up function to
call at every beat to check on user in void so we can run init in there. we
should always run transition init on the structure stance we just arrived
into. if stance is undefined because we are on void, then we need a function
to check on user still, just like we have orb_up and ghost_up

husk inwards:(void)(husk)
User impulse reaches the center of a husk. All void sea activity gets the Offscreen tag. No orbservable changes on
the prim state from the outside of the husk. A new circle state is created,
start with prim radius. Starts zooming inwards to screen limits? Maybe just
cover screen with impulse blue and alpha out to see the grey husk covering the
screen. 

husk outwards(husk)(void)
How do we get out of a husk without breaking it?Maybe send an empty prompt.
If we send a line txt into the prompt, the husk gets its name? not sure but
for now: 
White line fast coming out of the Husk. The command line. Fade in to black.
Fade out, Husk in the middle of the screen.
All void sea activity is visible again.

orb inwards:(void)(orb)
All void sea activity gets the Offscreen tag
Fade to black. A single line of Light traveling really fast. Fade in orb
escence colours. Then fade out. An orb escence circle line surrounding the
screen. Animations already running if any.

orb edit:(orb inner)(orb edit), (orb edit)(orb inner)
White fade in and out. same with editor in and editor out

orb perform:(orb inner)(orb radiant)
All screen filled with orb escence. Lid eye open up.

orb reform:(orb radiant)(orb inner)
Lid eye close down. All screen filled with orb escence and fade away, back to
empty circle escence

orb outwards:(orb)(void)
White line fast coming out of the Orb. The command line. Fade in to black.
Fade out, vessel in the middle of the screen.
All void sea activity is visible again.

orb born:(husk)(orb)
A new state with orb escence starts growing from the middle to cover husk
completely. The a black circle growing from the inside and stops at radius,
leaving a single circle color line vibing. Run animations if any. orb stance.

orb death:(orb)(husk)
A color line thunder like breaking the the orb.Line stops vibing. Turns white.
Then fade into grey. Husk stance.

The black void sea needs always updating no matter the stance.
We need to create a tag to prevent drawing operations on states but still perform
all logic operations. And call this tag on states when stance requests it. //done





... husks are interesting places since they represent a space free from void
and memories influence. Its a liminal space. A ghostship.. and a restrained place.
Maybe they could hold a history and be used as a place to leave messages..
Or maybe after a certain quantity of words it react somehow..
Or maybe the first word prompted by an entity inside could become its name and
grant it a an orb to contain the entity soul.
Husks might be used to hide in certain cases.

what about commands..
we should be able to send commands to make orbs play acts from void stance but
such orbs need to be in radiant mode
we can send a commands to make an orb .perform or reform.
from void , orbs modes should affect vessels animations. and perhaps reactions
to waves. Maybe radiant mode could be susceptible to pulses and impulses...
or just impulses... whilest inner mode vessels might react to impulses or
ignore pulses..hmm this is interesting

waves
When a pulse meets a husk, its energy is used on hiting it, so both pulse and
husk is vanished
Another way to prevent a pulse to move forward is by hitting it with an impulse at
any point. Users can prevent pulse trains invading by creating many impulses around a
place to protect it.
Too many consecutive pulses will debilitate a vessel to the point of cracking
it. Once a vessel is cracked, its memories get corrupted by the black sea,
creating unexpected effects and compromising user control over it.
A vessel can also be affected by impulses from void entities. If an impulse
manages to reach the center, a battle for control breaks out in the inner
space of the vessel, between the entity that created the impulse and the vessel
memories, its orb.
orbs without vessels are released from its bounds and become self aware and
self driven. How a free orb will behave will depend on its nature and its
memories.

Paradoxically , the more memories an orb cultivates , the less protective its
vessel becomes and its desire to be released into the black sea to become
independant intensifies.
Young orbs are resilient to pulses since they have a recently discovered
desire to grow and learn and protect themselves from the black sea.

So a vessel might have different properties depending on its numbers at the
moment it was conformed, affecting how its soul will express.
Some orbs might express less interest in being released from its vessel.
Others might prove to be more resilient than others. Other might be able to travel
very fast or others might have all kinds of curious effects.

So. Am finnally understanding Sunya is not simply an editor on the
browser.
Its a highly complex and fully customizable , high performance  strategy game with an inviting narrative ,
fourth wall breaking dynamics, scalable, accessible, empowering, single mode and online
functionality.

needs clarification.. ok so:
void_up updates prims , waves , husks and all things related to void sea. We always need to check all these elements.
BUT we first need to check logics that affect these states.
Radiant orbs performance also run in parallel, so we need to check these as well
We then need to check for user stance because this will allow us to know what the user will see on the screen
if user on void, then we should see the section of the sea the user is located on.
If user is on orb, then what the user see will depend on the orb mode.... now... what if we just create a stance for each mode.
This seems more straightforward. ! we cant make radiance a stance tho because radiant events need to happen wheter user is
in control of the orb or not. so it makes sense to have a single orb stance and then asking for mode
ml_up needs even a new name, it should be something like: orb_up .. void_up .. and com_up instead of c_com.. and tch_up
We could tag all states that need to be seen when user is on void stance so its easier to hide elements when we want.
Tag all states from radiant orbs the same way, so we can just hide its activity when user is not in radiant mode.

Okso
Am definitely checking all states so i might as well just loop all anim_a once. Not all states require the same atention .
So we ask, what is, what is it doing... we have vessels, husks and waves.
Vessels have a prim and an orb, husks have a prim and sometimes a prescense inside. Waves have origin, they are connected to
their makers, and they have phases. impulse and pulse.
We will also find txt states on all anim_a....
ok we can ask the same questions to all the states... but.. hmm
When we find a vessel, we ask for its animations... its ok to just let animf ask all question related to animations

Ok so first we need to check for commands on the command array. we read one command per heartbeat. Commands change 
user and orbs logic. Commands need access to orbs and user logic.
We then check for orbs logic. If user is in control, we need to listen to input on all different orb modes.
If user is not in control, we only check for radiant activity by running runa on orbs playing scripts.
Logic changes affect states so in this phase we need easy access to states.
After that we update prims and elements in the void sea which can react to changes in logic.
Finnally we update all animation states. Clear and draw.
This is how is currently working now. Kinda.

Ok so am thinking, why not just loop for every states, and go deeper into it as we need to
Just let anim_a loop fully take care of each state.
what is it? what is it doing? does it have a soul, is the soul requesting something and so on..
Ask for commands first. c_com is good

if(entity) > if(user) > if(husk) > if(stance) > if(prompt input)
if(vessel) > if(mode) > if(instruction)  > if(command)
if(wave) > if(phase) > if(impact)
.. so its commands themselves what needs access to all. user command line.  
 
Ok am noticing something here.. this structure puts impact as the phase that already had access to everything that came before.
To ask for vessels straight away is most effective because we inmediately have to access its orb.. maybe orbs should actually be
refferenced directly in vessel objects.. instead of having this old up_objs array
Then again... impacts create husks...husks create vessels(with help from a void entity prompt).. vessels create waves.....
waves generate impacts..
Impacts create husks.
Husks come before vessels because vessels need to access its husk data to create more refined logic.
Husks conserve wave data. Time of impact(birth), origin(void entity), size, potential..

Instructions can also read commands(instructions are act scripts)

Vessels are prismatic, Users are white command lines and lines in general,
Husks are greyish and purple, Waves impulses are blueish and
pulses are redish.

Got a revelation about radiant mode.
Imagine, radiance would make the vessel prim literally take the form of the
screen. A colored orb escence line rect to contain all animations created by a
script. To be seen directly in the void sea... this is exactly what i want.

entitys have: ...
users have:
membox for keys, stance, orb in control, translate position, init boolean for
transitions, name, speed, waves data
orbs have:
membox, vessels prims and inside data for animations, modes, radiant animations
husks have:
prim data, inside view data, origin data

So user should have stored refferences to orbs.. no orbs need to reffere
users. We alway have to check every orb .

Orbs need a specific sized vessel to be able to manifest with the .in command


Working on commands now. stance uses birth date to make corresponding commands
available. we need to adjust all commands now


orbs and husks live in all.fleet_a now. we identify these by birth date ,
because husks have no name
We have to loop fleet_a to check for radiant orbs.. make this happen

circles states on animf now will be asked for their form: vessel, husk, wave
vessel_up updates vessel prim animations. husk_up for husks, wave_up updates
waves dynamics.

user will now be able to displace trough void. We are going to use one canvas
and we will translate to show different parts.


husks need birthdate, x, y, rgba, radius se, birthdate of impulse and birthdate of pulse
that created it
a history property? a list of entities inhabiting it?


vessels need to share their name with their orbs. x, y , radius, rgba, se, birth dates
of all elements that came before it

i think we will need 2 loops on anim_a after all.. because unshift is too
slow to be used so often. but we cant run vessels scripts or check user
commands at just any moment on anim_a loop because we need to apply changes
before updating animations.
so its:
first loop
check vessels, husks and waves . if user on stance check orb mode acitivity
and commands
second loop
update animations
then draw using cue

aight new ideas
We need pupil, a circle state to help with transitions along with eye lids
we need sub events to be called on directly on prim form updates on animf

transition still needs a bit a of work. orb edits might need more
specifications . ok done. we just need to build transitions now.. oh jeez

we need transition to set new limits to displacement. yeah i like the idea of
displacing while inside a vessel or a husk

so the order in which we draw on anim_a affects whats  on top
maybe we can have more than one anim_a array.. anim_b , anim_c
We run all the same operations but we simply run them on each array consecutively
So images we want in top are pushed to anim_c and images we want on background
go into anim_a .... i think this is a good idea
also consider clearing just once the screen, no more computations to clear parts
we have to move the translate phase to after drawing probly.. why not just
process commands and se updates after animf?
clearing all once at the begginning of animf solves a lot of problems. ok lets
just do it. start adding layers instead of ctx to editors elements
txt by default should be layer2

users should be able to see other users working on orbs when broadcasting.
but while on radiant mode stance, users should only see other radiant orbs?

when we press alt at start, it throws audio context error

we need to improve the timming for pulse and impulse synch to create husks

a good one.
in radiant mode, soul is shrinked to a small radius, this circle now
represents a vulnerable point of the radiant orb. The big circunference around
it represents its range of influence while on radiant mode.
radiant can proyect impulses or displace as far as its range.
Range of influence is determined by vessel radius.

.orb.[orb name].vision	A command to fast travel to an orb current position.

So commands atached to keys could be executed over and over again as long as
user is pressing the key. Might be interesting . And it could be used to
displace around.

Users should be able to broadcast their creative process so editors activity should be visible to the void sea.
we simply project a prismatic rect? white.. this color is better
because editors are dominated by the command line..
around the orb prim position and show all activity for other users online.

//scroll img cursor. needs to be a command for keyboard users. untested
//we should not need this anymore because now we will be able to move freely always using the displacement commands
//.. so maybe we dont even need limits for vessel movement while editing because png images might be very big
//however we are going to need to limit the space where animations can be placed acording to limitrad... or maybe we dont
//even need that. what if we can just put animations wherever we want but can only create interactive effects inside the
//orb soul radius? and maybe there could be a way to trace the animations into its orb generating them? Yeah i think thats ok
//for now. I kinda like that we can just draw images anywhere in the whole void sea that is contained in our canvas ..
//.. how far can we go into X and Y on a canvas?
//... wait.. this function was being used to change bg values..... hmm

ok so editors coordinate system needs a sirius review
We want to work in editors having the central point as our vessel prim
location. We want to be able to place frames acording to this center, so we
use a cross in the screen to have a clear refference.. could be just a circle?
We need a universal grid, because if we use the size of the screen as
refference, then animations memories wont be compatible between different
machines, because phones, computer screens, they have different sizes, so we
cant use a grid in refference to the screen, we need to create a grid around
the center. The animated edits will project from the orb center when we link them to
acts so we might as well create them using a central point as refference.
From the center to the left its negative X , to the right its positive X
From center to upwards its negative Y, downwards its positive Y
Its a cartesian grid?
So when we project, we use x0 and y0 as primx and primy
An x100 y0 location would be 100 pixels to the right of primx
An x0 y200 location would be 200 pixels downwards of primy so it means we add
X and Y values need to consider the central grid. When user changes x to 100, its telling the edit to place itself 100 pixels more
to the right from central position which will be different acording to orb position on void sea.
We dont see the position its going to have directly on x and y, on edits,
these values represent the position in refference to the central point.. so
maybe all we really got to do is use tx and ty to work here. Just adjust tx
and ty values to match user center screen location. ok try if this is good. it
is. this is the way.

ok so we need to clarify some concepts here.
when users get inside husks , we stop seeing their prim because we are inside.
so the radius of the ghostship is the size it might have as a vessel if named,
but this proyection is merely a representation of the husk from inside. its an
atmospheric experience. Seen from outside, only the husk prim is visible, not
its ghost radius, no matter if entities are dwelling inside, a husk cant
project its ghost radius because it doesnt have a soul.

when orbs are controled by users, its vessel radius is projected into the
void, so the radius of the orb vessel can be seen from void, and it becomes
even more powerful when orb is in radiant form because now we can act upon
this radius using act scripts.
The prim is still visible while in control of the orb, and this is actually
the vulnerable point of the vessel, its memory orb, its soul.
The radius vessel becomes an instance to protect the orb soul.
It also defines the range of influence and how far we can place animations run
by the orb

an idea. users capacity to create waves strength increases with user
birth_date

the way some void entities hunt for orb escence is by taking 3 consecutive screens from
random pixels in the sea and annalizing their rgba values. once they get a
match they start sailing to the location of the pixel. so users can lure
certain entities or hide away from them by manipulating pixels colors
sequences

orbs radiant souls can change the void pressure inside its range.

radiants can prevent other radiant from moving into an influenced location on
certain conditions

so when we get out of a vessel, dont need to relocate view ..

copying the object from the console into vim is possible so we make tools a default memory
in sunya eventually

when displacing, a white rect should be visible in the periphery of the
screen. the command line is draging the screen around in the void

should we allow void membox always by default on all modes? no the whole idea
of having unique membox for each mode and void is to be able to have many
"controlers" in one keyboard

the ___soul state will now be part of vessel_up, because we want to project
the soul to the void. orbs mode transition will change ___soul se acording to
modes. We need a new name .. maybe vessel in___at_field //done

inhabiting a husk should be a spooky experience. a grey purple ish fog should
cloud the user screen a bit

we want stream to follow around user displacing trough. we can always turn off
streams with left arrow anyway //done

i think we do need custom_a for circles. We could simply control animations by
changing custom_a beats... no need to implement on editor yet , just make
animf capable of working with it, just like with txt states // done

Use selection and J on vim to turn multiple lines into a single line. amazing
:set joinspaces!
First set your vim so that it understands that you want 80 characters:
:set tw=80
then, hilight the line:
V
and make vim reformat it:
gq

how could we turn empty arrays into a symbol to let animf know its an empty
array.. would that improve the efficiency of the operation?.... //done

Doolittle


//full intensity wave
[[ 0.7, "a" ], [], [], [], [], [], [], [], [], [], [ 1, "a" ]] //just alpha 
[[ 0.7, "a" ], [], [], [], [], [], [], [], [], [], [1,"a",20,'b',20,'g',220,'r']] //red pulse
[[ 0.7, "a" ], [], [], [], [], [], [], [], [], [], [1,"a",220,'b',20,'g',20,'r']] //blue impulse

//almost full intensity
[[ 0.1, "a"], [], [], [], [], [], [1, "a" ]]
[[ 0.1, "a"], [], [], [], [], [], [1, "a",20,'b',40,'g',200,'r']] //red
[[ 0.1, "a"], [], [], [], [], [], [1, "a",200,'b',40,'g',20,'r']] //blue

//low intensity
[[ 0.6, "a" ], [0.1, "a"], [], [], [], [], [1, "a"]]
[[ 0.6, "a" ], [0.1, "a"], [], [], [], [], [1, "a",20,'b',60,'g',180,'r']] //red
[[ 0.6, "a" ], [0.1, "a"], [], [], [], [], [1, "a",180,'b',60,'g',20,'r']] //blue

//orb escense. this one needs a very particular pattern :D
//lets use the 12 tones of the Archon institute

[220,"r",220,"g",220,"b"], //white
[[176,"r",215,"g",235,"b"], //celeste
[91,"r",157,"g",237,"b"], //azure
[0,"r",4,"g",233,"b"], //blue
[97,"r",28,"g",188,"b"], //purple blue
[138,"r",12,"g",152,"b"], //purple
[0,"r",0,"g",0,"b",1,"a"], //black
[255,"r",10,"g",6,"b"], //red
[255,"r",152,"g",1,"b"], //orange
[255,"r",221,"g",38,"b"], //yellow
[163,"r",238,"g",4,"b"], //green
[127,"r",224,"g",191,"b"]] //calypso

//command line
[[],[],[],[],[],[],[],[],[],[0.1,"a"], [], [], [], [], [], [], [], [1,"a",220,'r',220,'g',220,'b']] //white blinking

[[],[0.9,'a'],[],[0.7,'a'],[],[0.5,'a'],[],[0.3,'a'],[],[0.1,"a"],
[],[0.4,'a'],[],[0.6,'a'],[],[0.8,'a'],[0.9,'a'],[1,"a",220,'r',220,'g',220,'b']]//charging up wave

//Death
[,0,0,0,[0.1,"a"],0,[1,"a"]] //just alpha
[,0,0,0,[0.1,"a"],0,[1,"a"]] // to dust?
we could strip intensity on each beat with to dust se.. the first beat might be intense white and then just strip
items from custom_a until removal

vessels also have intensity(the new hit point system?) so death ends the job when there is no intensity left

void pressure should be local to orbs... we dont want to mess the whole void pressure with each wave, this pressure net
needs to be localized . what better than orbs atfield to contain it. yes this is brilliant

user trying to destroy void limit. 
Are you trying to enlarge your computer screen? Perhaps you should try buying a new one?
Are you testing my limits?
Hahaha .. (ominous laughter)
You are trying to destroy the walls of your own Castle?


Its not an office, not a supermarket, not a church, Its not a company, its not a....
See Ymity you build the Bricks. They need to be hard, lightweight, resistant to the weather, reliable, well constructed
solid bricks because am building a Castle.
We need the garden, the bridge, the knights, the kings, the queens, the
analogy goes on for ever. For this is a fight for survival 
This is the brave new world baby , the vampires are shaking, because we are
the sword God is wielding to cut the eternal
darkness into little pieces
because If we are going to war lets make it real man
We will need to fight back against the sieges, we need good armories, good weapons, strong soldiers
And lets give our oponents a chance to fight back , for we need to be just, we need to be the Light, not the Darkness
we need to be open, understanding, authentic, humble
Maria?? She is the host brother she is the Heart of the Castle(the sweetheart
i would say), nothing happens without her, we are all here because of
her dont you understand Ymity?
Its not about good or bad languages, its not about who is better, its about knowing you place. 
(insert cool kanji)
Its about building up
together.

lets just use custom system for all forms, its by far easier to code , more versatile and clean, and its even more efficient
than frames system. also, it adds to the narrative. Who needs hit points when we have intensity frames

so atfield range could determine how far orbs can generate pulses and also the maximum pump possible. In this way we
avoid orbs influence too far beyond comprehension

so now am thinking wouldnt it be better if we just ...wait one second
The idea that drives me is to reiterate trough arrays just once if possible.
We are looping animf once and pushing stuff into other arrays. this helps to
have control over drawing layers. so what if we also push state prims like
waves, husks and vessels so they can be processed with more specific
questions..
The idea of looping anim_a while in a loop inside anim_a already makes me a
bit confused.
Lets say i find a wave , and i want this wave to compare itself with something
else. but it could be anything


//maybe we could add the intensity of impulses .. but movement needs more thinking
//i dont like the idea of negative intensity, impulses should simply have a different way to be handled, we can already charge up
//husks to build defenses.. impulses should be able to go trough pulses..ok here is an idea
//impulses can charge up husks to build defenses as long as husks are inside the at field. if we move the at field while we got
//charged husks, then the husks that are left outside the field loose the shield and are left vulnerable again.. or maybe could
//simply get destroyed.
//The way we displace an orb is by creating impulses inside an orb at field. However the condition is, the impulse created must be
//greater in radius than the vessel soul, the orb, and must have the precise charge so it ends on implode, radius zero.
//also maybe, we need to cast 2 exact copy impulses at the same time(only possible trough scripts) , one centered on the orb, and
//the other one in the location inside the at field we want to transport the orb.. what if its a husk?
//This would make sense because moving would take time and could be also timed to evade certain attacks.
//we need impulses and vessels to completely ignore pulses that didnt touch them with their radius. only the radius line of the
//pulses should be destructive and ractive
//Pulses from an orb should not be able to damage their origin memory structure.. but can damage the orb own defense husks inside
//at field.?
//Defense husks shields. In order to be charged up, impulses need to implode inside the husk radius, they need to reach radius zero
//anywhere inside husks radius, anywhere but the center.

//All waves coming from an orb can time their subevents to orbs animations so users can synch any animation properly.

//Pulses generated from the center of an orb can be molded and infused with special effects.

//maybe pulses can also be molded somewhat by the proximity with the orb at
field radius

//Colors. the pixel triad rgb can manifest in a higer order of 12 tones.
//Prims take specific aspects and strengthen them acording to their purpuse. An idling orb (vessel) soul will cycle trough the 12 tones.
//An impulse will manifest the tones dominating one side whilest a pulse will intensify the oposite side.
//Husks resist and opose one aspect(fire) while being strengthen by the other(water)
//
//User name could determine the color of the command line by reduction.
//Command line blinks color take over whenever a user is editing an orb. When running animations on inner mode, orb and field take
//a darkgrey tone blinking. Orbs and fields dont interact with waves when they are running animations on inner mode or when
//they are being edited.

we should be able to modify commands faster. how about  : .button.[KEY or name]
showing and printing on input bow the command so we can easily modify 

Maybe implode could hold white a bit, so user can confirm action. in this way,
maybe we can create multiple options for movility and decide at the last
moment 

Tools have a running trunks animation, but image not loaded so it throws error
we need to prevent animations with no image source to run

ok we r doing great.

Make help text a bit more clear and white. Also, dont put help messages on
history. Its complicated. stream needs history to work properly. Maybe we can
implement a function to create an instance to remoce all stream messages that
are not from help .
we also need a similar instance to delete and create audio context once and
then so it doesnt pile up too much timestamps data?

We dont want to neccesarily travel to orb when controled, we could use another
command for that .orb.name.center/travel 
.orb.name.control should simply allow us to put user in control of the orb but
remain in the location? what for tho

a script instruction should be able to displace user when controling that
radiant orb on demand.

thinking about yoinking edit circle and edit rect modes completely....
users will want to creat animations using images and txt for sure, but i dont
see them interested in playingwith circles and rects. And since we are doing
waves physics now i doubt we will need to craft these rects and circles on an
editor.. give it a couple of spins

i probably need to stop using undefined in case we want to convert to json 

Ok so .. am thinking now... User object should have all keyshorts. All
keyshorts should be available on all orbs under user control... this is far
much more practical. We dont need to have such specific keys stored on orbs...
yeah and also remove circle and rect editors ... am pretty sure noone will use
those.

Ok so we need 2 history arrays. One array keeps the last lines acording to
limit and thats what we use to print all stuff with effects and all
While the other history only keeps the txt and the non repetivive ones, like
we dont want to keeo help text on the history


//Since we dont want to shift anymore, we are going to work with 2 arrays in sequence. we print first array from top to bottom,
//last message on top. When we reach stream limit, we just start using our second array first, and complete the rest of the first
//stack using limit. At every loop, we use top to bottom of our second array, and fill the rest with our first old one. When
//we fill our second array, we just flush the first one, and start stacking new messages again and so on. Its a duet :D

//Since we dont want to shift anymore, we are going to work with 2 arrays in
sequence. we print first array from top to bottom,
//last message always on top. When we reach desired stream defined limit, we
just start using our second array last item,
//and fill the rest of the messages using our first stack until stream limit.
At next iteration, we use the stacks from
//top to bottom of our second array to print,
//and print the rest of the messages limit in our first old one. When we fill
our second array limit, we just flush the first one
//entirely and start stacking new messages again and so on. Its a duet :D

displacing should have a white noise animation

We could synch cursor blinking with orb vessel and field blinking when on edit
mode



“First sentences are doors to worlds,” wrote Ursula Le Guin in her essay The
Fisherwoman’s Daughter. Which is to say: in the hands of our greatest writers,
opening lines cast an immediate spell, grab your attention like a starter's
gun, set the tone and even foreshadow what is to come.
Let us know your favourites on Twitter or at editor@penguinrandomhouse.co.uk.
'The King is dead. Long live the Queen.' The announcer's voice crackles from
the wireless and winds around the rapt patrons of Berlin's Milk Bar as
sinuously as the fog curls around the mournful street lamps, their wan glow
barely illuminating the cobblestones.
Once there were four children whose names were Peter, Susan, Edmund, and Lucy.
This story is about something that happened to them when they were sent away
from London during the war because of the air-raids.
BUY THE BOOK
The Lion, the Witch and the Wardrobe by C.S. Lewis (1950)
I am an invisible man.
It was a queer, sultry summer, the summer they electrocuted the Rosenbergs,
and I didn’t know what I was doing in New York.
The Bell Jar by Sylvia Plath (1963)
It is a truth universally acknowledged, that a single man in possession of a
good fortune, must be in want of a wife.Pride and Prejudice by Jane Austen
(1813)As Gregor Samsa awoke one morning from uneasy dreams he found himself
transformed in his bed into a gigantic insect.
Metamorphosis by Franz Kafka (1915)
Mother died today. Or maybe yesterday; I can't be sure."
—The Stranger by Albert Camus
The Man in Black fled across the desert, and the Gunslinger followed."
—The Gunslinger by Stephen King
It was a pleasure to burn."
—Fahrenheit 451 by Ray Bradbury

an option to use cursor instead of first 2 parameters of wave command //done




The Void King
sets kaoz mode to true . The King wont clear anything in the screen. This is
how he tries to teach you that everything has a fingerprint, and nothing is
really erased once it exists.
To beat the color madness, user needs to completely change its color strategy

We need a tutorial. A key combination is asigned to run a command that starts the
tutorial. 

.. we need to move all commands into user. This comes first. // ok done

We need a command to atach the screen into a wave

we need the white noise on displacement. into the trees of a dark forest

You can surf the waves. An option to follow a wave radius . Amazing

We need a cursor

forget about the whole script thing for a moment. Remeber that old idea of
simply asigning animations into events.
We need to be able to make radiant orbs interact with all waves. Users should
be able to go to void stance, leaving an orb in radiant mode, and interact
with it using waves

when a wave implodes in the center of a vessel, it links that prim intention with the
the wave, resulting in a pulse that has special characteristics.

If the wave initial rad is less than the vessel rad, then it can only be embeded
with pulse events.
If the wave i r is equal or greater than vessel rad, then it can be used to
request a vessel displacement.
If the wave i r also allows the impulse to touch another vessel in its surge,
then it can be used to affect the other vessel in a special way when imploding
point is reached.

The pulse can be asigned a target, it can be asigned a quality, and these
effects are also enhanced with a pulse intensity.

Wave pumping, clashes and implosions are events that can inform orbs in order
to determine when linked animations will run so everything can synch properly.

so maybe default effect on pulses is bash(damage type) and no target(first on impact).

we could use impulses to get information about unknown prims. orb gather data
in this way to perform automated acts. data obtained is stored on orb stream 

maybe some attack type can interrupt impulses. .. blade or corrupt

we need to create a good cursor. We can use it on edit modes too.
AM thinking editor needs to merge all tools into one instance. Creating rects,
circles, text .. lines.. we need to be able to trace lines from one point to
the ohter. all on the same instance. a command to save frame. we need lines..

ok we need one more custom implementation feature..
We want parameters to choose randomly from a selection of values
var arr = ['some','nasty','cricket',3,'basket','ting']
var rand = all.get_r_num(0,5);
var value = arr[rand]
we should be able to apply this into scripts waves as well so users can
instruct animations to work with a specific selection of values. randomly or not

inner mode on idle not in control needs to be empty

in radiant mode orb needs to be filled. But color needs to illustrate orb
actions. Damaged, low in energy, attacking, what kind of wave it is synched
with etc

solo leveling, sao , overlord, log horizon, shangri la frontier

maybe we could print keys with commands asigned permanently on screen

ok we need to make impulses faster and at least bash pulses slower //done kinda

we should also be able to asign random ranges to stream properties

Thinking about making each kind of pulse apart. The whole impulse implode
pulse cycle is a bit complicated to compute and also, it involves asking too many times some things.
Ok so what if we have impulse and pulse commands instead of a single wave
command
This way we have more precise control over what we want to do. Because when
void pressure changes, the strength values required to complete the cycle also
change, so when an impulse used to work, now it will become a pulse after
imploding, a pulse we have no use for and could actually do things we dont
want it to do. we dont want user to be worried about calculating strength so
waves dont become pulses sudenly. there is no real reason to have only .wave.
we need .impulse and .pulse //done
Apart from these 2 basic waves, orbs can also cast
.focus , .blade , .corrupt
And orbs can cast all these waves simultaneously, something users cannot do.
Many waves create special effects when their ids are in synch(casted simultaneously)
or when they share a common center. 

So act scripting will now revolve around creating waves that interact with
prims. We will be able to create waves sequences and link animations on
pivotal events triggered by various waves interactions. No more resource
abstraction resource logic packets, all we need is a solid wave system. Orbs
streams will now be used to drive radiant orbs acts, impulses will gather data
to be used on waves dynamics.
Ok so we probably want a radiant orb to have commands to send these new waves
manually first, so users get a feeling on what is available from a radiant
memory. Scripts will still hold unique features since we will still only be
able to cast one command at a time, but scripts allow us to cast many waves at
once, by running the script, and also we will be able to synch animations with
the waves trigering events.

Act updates main lines numbers
9319
9451
10829
4005 o.radiant_mode updates init
1832 orb perform
9339 new waves on radiant mode

I just realized, we dont want to wait too much for an impulse to start. They
need to be a bit faster

ok we really are doing this.. oh jeez.
ok but first we are going to need radiant mode to work and users being able to
use radiants special waves. Then we update the act system.
Act script system should simply now be a way to create multiwaves , process
stream data, and link waves events with img, txt and audio edits.

we are going to use ctx.isPointInPath
we can use ctx.lineWidth to change stroke width

ok when we compare waves, 


_______________
/*
 *
Act scripts will now provide keywords to create instructions to manifest groups of waves.
each wave frame can be linked an animation of any type to run in synch. All animations linked can be interrumpted and linked
with other animations at any moment. scripts trace every wave activity. is there a maximum number of waves we can cast?
Maybe we can control that by increasing pressure and changing waves speed . So too many impulses might slow down their displacement
speed making them easier to be imterrumpted.
Orbs should be able to cast Focus waves one at a time. That makes sense. How about pulses.. Pulses rise in speed and instensity
when they combine, .. maybe we can restrict pulses by giving them a cooldown for each wave cast in between.
Blades should have very little restrictions except for getting slower when there are too many?
maybe we can [wave] to access a wave position and current event at any atime to ask and synch with animations.

Wave System
Orbs can use waves to express their memories. ?

Synthax
All instructions return a name which can be used to refer to the element created by the instruction.
Conditions check for the existance of the first name in a statement and if the name exists, then the instruction runs.?
No. We want conditions to be independant. We keep the old synthax here as well
these are test statements
[tag]/param=[tag]/param{cond} 12
[tag]/param<[tag]/param{cond} 12
[tag]/param>[tag]/param{cond} 12
		//
so we can do;
{cond}[tag]/param+[tag]/param	etc..

these are operation statements
[tag]/param+[tag]/param 10
[tag]/param-[tag]/param 10
[tag]/param>>[tag]/param 10


Stream
Access orb stream to gather points and other useful data gathered by impulses.? data packets provide insight levels from the orb?
surroundings. we should be able to pick packets, annalize them and extract points, insight levels from other vessels and ..
Ok what really is a stream. A stream is pretty much a box with instructions to create lines.. well stream is actually the
system that prints these lines.. we need control over the stream configuration. We can already just put text from data boxes
...
stream is just a tool to place a line in a place.. this place could literally just be a test animation.
so a stream is a text that keeps pushing lines and removing the last one.
Maybe a stream is just a running text. I love the idea of having many streams moving at the same time. You can just go and look
in the history of a specific one. So every line written by someone can be easily seen. Every story clearly followed.
Always a place for everyone s story. Nothing gets lost in the mainstream, because there is one stream for each voice.
So an instruction to read input and place it somewhere else. thats it
/input(new input name)
This instruction means every time user presses Enter , the input data is going to be processed. Not at every beat.
If there is no new input , then [input] element is not even created. So all operations using [input] are simply ignored.
However , it would be more consistent if we had to ask and atach a condition  lock
[input]/all{stream}
{stream}[input]/all>>[txt]/nline	If stream, place all input data on a txt new line
{stream}[txt]/print		..and print(update the text once) .So we add the new line and let custom_a system do the beats
We can have an instruction to display specific lines only from a text run once , like this;
{stream config}[box]/1>>[txt]/limit	Box 1 could hold a fixed number. The number of lines we want to see from the text in this case.
And we ve created a stream using script instructions only. Neat
The text is only updated when a new message arrives.

The idea of storing logic values in a box is good, lets keep that. so we do something like:
/box(new box name)
This literally creates an array to store stuff. 
We can access data on the box by number
[box]/0 ... /1 /2 /3
We can access the data in the box randomly like this
[box]/..1-3
This is just an array
We can make a specific item in the box always return a random value in range
#..10-30>>[box]/2
We could could fit in here a way to use values in the box sequentially like
[box]/cycle
And when we want to use the current cycle value we do
[box]/current
We can always asign a value to current directly in case we want to restart the cycle from a specific item going forward
[box1]/4>>[box2]/current

We need a way to end the script play
{end condition}/end

so what if..
[box]/all>>[txt]/0/0
This would put all values in the box into txt beat 0 on line 0, now thats kinda crazy
We could also extract a box..
[txt]/0/0>>[box]/all     .. custom is not a good name i think for that array. The beat containning array.
So we can access an array inside another array..

It would be cool if these autocomplete, so we just change the values. WOuld be way faster to create scripts
User type in the first word and autocomplete sugests all possible requests. Or builds the structure for you so you only need to
fill the gaps.
[box]/0=#scan1{init scan}
{init scan} /scan(new scan name) #100>>[scan]/x #100>>[scan]/y #120>>[scan]/rad [scan]/cast
[scan]/result{process data}	Return a box with gathered data to be annalized. Dont return anything if the scan hasnt arrived yet
{process data}[scan]/result>>[box]/push

So by default, scripts keep iterating. we can /end a script to end the play explicitly from inside the script, or a script can be corrupted
into stop running.

maybe we need a synthax notation to denote read only, writable, its a box, its a comand..
Some instructions will only return a value, some intructions will also expose the value to be changed? some others will execute a function
some instructions depend on others. say if we ask for [scan]/result , it wont throw anything unless a [scan]/cast was previously called,
and also, this cast needs to land on center in order to being able to deliver the result.
We want specific instructions to run in an independant script and have an effect on other scripts.
The /orb script unlocks new commands when an entity is around or centered in the husk, turning the husk into an orb.
.txt:name Is available since husk, but an Orb can now do;
.load.img
.load.audio
.img:name
.audio:name
.osc:name
We can now,,

The /vessel script unlocks new commands and instructions?.. Maybe we only need to unlock instructions.
Perhaps Vessels should be controled with instructions, not commands. Commands are an Orb thing. Instructions are a vessel thing..
We want now a command? to say, focus screen in a point inside the field or send a request to displace the vessel to that point.

OKOKOK so when we create say a txt.. Its already running? we want to use commands to edit the text

!!!!!!!!!!!!!!!!!!!!!!!!!!!!
OK i got it.
ORBS , HUSKS, VESSELS , WAVES
So any entity can create a memory and the husk will store it. Any entity can move
around memories inside the Husk with commands and also run memories using its
own location as refference. Memories can be manipulated only by their creator
entity? but can be seen by all entities in the husk. These memory centers will
now be called Orbs. Scripts have no effect on
Husks. For scripts to play the Husk needs to become a Vessel.

To become a vessel, the husk must have a single entity inside and cast a
specific command to name the Husk and transform it into a named Vessel. Once a
Vessel, owner can create scripts to cast waves and synch animations in memory
with wave events.

We want to edit a script while playing. Yeah this is novel. We want to edit many scripts and watch them play.
We want to visualize scripts playing.

So txt editor will now be self referencial. Certain instructions will have to
be running in order to unlock certain other instructions.?
By filtering the input , we will now prevent other entities from modifying a
script.? We can also ofuscate scripts by moving their location,
changing their beats values and painting images over them. We can also move Orbs themselves to prevent them from being easily accessed
by other entities.


GAME FLOW COMMANDS SUBCOMMANDS
Users or entities on void stance can cast Pulses(Fire) and Impulses(Ice).
Fire waves are used to displace entities screen and also Fire Waves can be
frozen to form Husks.
Memory Orbs(edits and animations) can be created in the void but will degrade
fast. A Husk can contain Orbs integrity.
Memory Orbs are self contained memories that can be moved around and edited
while inside a husk.
This Void is a Giant mirror that reflects data using locations asigned by
reduction.
Entities can travel Sunya canvas to explore and find memories manifested .
Entities can capture Orbs by englobing them in Frozen Fire circles.
Frozen Fire Circles are Husks. Husks need Ice Stacks to resist Fire waves
passing trough them.
Fire over Fire increases its speed. Ice over fire creates a Frozen Flame or a
Husk. Ice over Ice ? . Ice over Husk creates Ice layers. Husks can become more
resilient to Fire depending on number of Ice layers.
Entities can add Ice stacks to Husks by casting Ice while inside a Husk.
Memories can be found,  created or loaded using commands.
.txt:name Creates a txt Orb with name. We can now run different subcommands on
this txt memory like this.
.txtname.run  , .txtname.edit  , .txtname.x:value  , .txtname.y:value

Some memories use files. Husks can contain loaded files for Orbs to use them
while inside the Husk. To load files into husks;
.load.img  , .load.audio

A command to name a Husk and transform it into a Vessel;
.name:newname
All memories will converge in the Husk center. A Vessel has a Soul where all
memories reside and a field, a larger radius circle around that delimits the
range of influence of the Vessel.
The Vessel soul is now linked with the entity that merged with it.
Before casting this command, there should only be 1 entity in the Husk which
will become the source of the Vessel. This Vessel will now become an entity s
aspect.
Entities can have many Aspects.
Vessels can create special waves.
Vessels can now control their memories and their wave creation using scripts
instructions.


VOID LORE
Sunya has many layers of depth. All new entities begin their journey in the
center. The Center is a safe place where only few weak entities dwell. The
further we venture away from the center, the dangerous it becomes for the
unexperienced, and the more rewarding challenges become.
The center is x0 y0


INSTRUCTIONS CLEAN
... and now am thinking .. maybe [anim name] could simply hold the Orb memory
name straight away.. no need to /txt(name tag) , [name tag]... This would be
very nice actually.

/orb(new orb name) //deprecat
/vessel //deprecat
/follow		Send a follow request to an entity around so screen entity ataches to the orb activity
/ofuscate ?
/broadcast

/input(new input)	This instruction will grab and manage any input inside a vessel field
[input]/data		Returns the whole input
[input]/source		Returns the entity that created the input.

Am thinking maybe a box should BE a memory Orb... like . the txt orb itself
... a literal array. Its just an array
We can use the command '[]' to create an empty box(array)
if '[tag]' doesnt exist , in allocated space already it creates it
/box(new box name)
[box]/push	A new value
[box]/cycle	Changes current value. current holds the value of an item in the box
[box]/current	Access a specific item.
[box]/all	Dump all items in the box
[box]/last	Access the last item
[box]/0.. /1 .. /2 .. etc

We use text to control the txt animation itself. txt animations will now be available to be modified by scripts.
/txt(txt animation name)
[txt]/nline
[txt]/limit
[txt]/print	Maybe print gets called automatically whenever the text changes?
[txt]/0 .. /1 .. /2 etc	Access text line
[txt]/0/0 .. /1 .. /2	Access text beat in line
A txt orb can run and it will display. But if a text contains scripts
instructions, then we can play it.
[txt]/play
When a script is running and playing at the same time, we can see highlighted
lines and get feedback on the sricpt flow in real time. 

Maybe images dont need to be modified by scripts.,
/img(img anim name)
[img]/run , /end

/bash(new bash name)
[bash]/x , /y , /rad
[bash]/start , /hit , /end , /time , /evaded , /current , /parryed

/blade(new blade name)
[blade]/cast
[blade]/start , /hit , /end , /time , /evaded , /current , /parryed

Focus waves need Insight Stacks to complete a certain data chain that will
allow the wave to search for its Target.
Once a Vessel has accumulated enough insight of the target , a Focus wave can
be casted.
Focus waves can be destructive of constructive.
/focus(new focus name)
[focus]/target
[focus]/start , /hit , /end , /time , /miss , /current , /parryed

/corrupt ?

-----------
/bash(new bash name)	To create a bash wave with default values. so now we can do
[box]/1>>[bash]/x
[box]/2>>[bash]/y	 ..and so on
#100>>[bash]/x	...
..wait. but we dont want to change these values , waves have a fixed behavior... so we can only set these values before
[bash]/cast
Similar to [img]/run , but once a wave is casted, only certain other parameter can then be accessed 
[bash]/start , /hit , /end , /time , /evaded



-------------
We can also access a wave subevent to synch with animations.
..i like this much more
So we simply treat all elements equally, boxes could actually ... well they literally are boxes.
All waves and animation types are just fancy boxes that the system use to create graphics, but they are bassically boxes with data
So box allows us to create an element to simply hold data so we can use the values stored to modifiy states values....
Ok so following this logic, animations could actually be writen in a script as well. because we can just modify custom_a... however
custom_a holds arrays... the script language now can only access 1 depth.. and
it should i think?
Animation editors work with 2 depth, scripts access the state created by the animations. Animations are objects with instructions
to create states... and waves are states so scripts can create and manage waves by accessing directly
Scripts should be able to create animation states by accessing the animation object stored in the orb first

The idea of accessing animation states from here is good as well, we can just ask if a parameter has a certain value, and if it does
we unlock a statement.
We are going to use t now on states because t controls the beats.
Am thinking we can do this now since there will only be 4 kinds of animations... img txt audio osc?

/img

/txt


We need a general function to let states pick from an array of options. We already have the randomizer '..23-340' , now we need
an array that could be used sequentially or randomly, that is,
leting states pick one of the elements inside the array randomly ,and ,
use the elements in sequence from that array. waves need to be able to do this.

So we need to be able to create boxes with values and ... ok before scripting, we need to be able to refine commands.
My initial idea was to be able to actually control pretty much js using these commands.

!!!!!!!!
My main goal is to get insight into what js can really do and create my own functions, and being able to call these using commands.
So, a command to create a canvas
a command to create an audio context
a pulse
an impulse
adequate to sound
create random values between ranges
create a box to ;read in sequence and, read randomly
!!!!!!!!

Movility
A command to print all elements on screen id.
.search
A command to focus screen on an elemnt using id.
.follow:id
We can use tab to move between visible elements. We can position entities on prims center or prims radius.
Tab only detects elements in proximity, that is, on screen.
Arrows will have a different effect depending on entity selected element.

Typing keys makes key combination on k_feed the selected element.
Pressing Enter makes the input box the selected element.
Casting Fire makes the fire wave the selected element.
We can select txt animations. img animations...

Scripts can send requests to make entities follow a specific element.
Elements can cancel follow on demand using an instruction. /offuscate Or follow on demand /follow
But we can cancel follow requests with the command
.ignore.follow
We can also
.ignore.sound ... and so on


Navigation.
Entities need elements to focus on. To anchor , we need to type in the symbol that an element is portraying and cast fire. Elements are
states.? We can cast fire with Backspace, we cast Ice with Spacebar
Any combination of keys can be frozen and then a command or a line can be asigned.
If a combination of keys is set on fire, it will send a pulse to find that combination of keys again in the void offering the posibility
for the entity to travel there?

So we cast Ice with Spacebar. The screen is frozen for a bit. if there are previously typed keys, they will freeze and the command
memory system runs. If there are no keys, an impulse is created to end in the center of the screen.
We cast Fire with Backspace. Screen goes red for a bit. If there are previously typed keys, the pulse generated will try to find
the combination of keys in the void and take user screen to that location. If no keys are type, a pulse manifests from the
center of the screen anyway and when it reaches screen limit, entity begins to move with the pulse, the screen now folows the pulse radius.

Riding the wave.
Entities can displace across the wave radius using Arrows and stop the wave by casting Ice.
Entities can displace across waves anytime a wave has been casted using Arrows.
We can create a Husk by casting Fire and Ice in time. 

husks have an initial size limited by users screen..? No..
When we ride a Fire wave, we can cast Ice to freeze the wave. Now this becomes the Husk. Frozen Fire.
Entities can now displace trough the radius of the Husk. We can now type words to be recorded on the Husk. The radius of the Husk
acts like a paper that can contain words... or just make the .txt command available

The husk can be abandoned by creating another Fire Wave now, but this will destroy the Husk. If Ice is casted while riding the Husk
it will be reinforced and become resistant to a Fire wave once. Many reinforcements will make it resist as many Fire waves as Ice stacks.
An Iceberg is just a very Old and Icy husk.

To turn the husk into a vessel, we need to create a txt(special memory box) and place it
inside the husk.An instruction to create an orb. We asign a name for the orb and the command will create a memory seed. Once the memory seed
is written on the Husk skin, it will be absorbed and the Husk will become a vessel field...?.. 
So the text we write on husk skin... is it a stream? ... or is it a text editor mode instance?
Bcause that would make a lot of sense. An open text editor !!!!!!! We can then run this script to create an Orb.. so an orb is pretty
much a script contained in a vessel
So we should be able to create txt in a husk.. And if we create a script with the /orb(new orb name) instructions and play it, then the husk
becomes an orb. We can then store animations in the orb. Orbs can create img , osc, and audio but cant interact with anything.
... the idea of husk > orb > vessel is setting me off now. Why not skip the whole "husk" part and just make frozen fire an orb inmediately.
This giant bubble can store boxes inside. simple. An alocated space for memories. We can create a text and it will stay in the orb.
However now , the text will always be running.. and so all memories stored in here will run in a loop endlessly. unless bound to a
control script... however, it should have a default script, and the script should be visible as it is running, and should give off
feedback too. We can see what the script is doing in "real time".
So commands what they really do is create objects and a script for the object. Everything has its own script and entities should
be able to modifiy scripts directly... so scripts play and contain memories.. memories are arrays of values..

Memories floating in the void without scripts to contain them can be briefly perceived while traveling trough the void.
So orbs scripts can contain memories... i like this.


We can then create a script with /vessel  instruction and play it to turn the orb into a vessel.
A vessel can now call all the waves and link waves events to animations stored in its memory when it was an orb.
So if these texts containing /orb and /vessel are lost, then the prim returns to its husk state.
I like this logic. We can do /broadcast to make the orb online..?
So all scripts run in a loop. As long as the /orb and the /vessel and so on script is running then the prim will perform as an orb
or as a vesseli?

We could use Tab to jump between Prims that are visible on screen.

What is a command line...
So maybe input needs to be stored on a husk or an orb to be remembered. Words should be overwhelmed when directly left on void without
containment. So husks could prevent words to fade away, Husks could work as public chats. What about husks fragility. HOw do they get
destroyed and what happens when they do. how do entities move in a husk prescence. What about husk size..

Maybe we need to be able to choose the radius of primordial waves. 

Arrows can be used to scroll trough stream?(txt anims) only when there are no primordial waves casted.(Fire or Ice)
Streams need a container..? 

Users carry their own memory to link commands into key combinations.
Commands are ubiquituous, they live in sunya script. they are embeded in the program code, they cant be modified. they can
be accesssed with a dot notation from the input element...
But some commands create boxes that need to be stored somewhere.

The void center is a special silent place whilest we go closer to the canvas limits, it becomes increasingly dificult to navigate further.
Users should start in the middle. x0 y0 on center. Use translate to move around.

Condition system from old act scripting is not bad, we only need to find a way to not use shift or unshift

pulse and inmpulse only available for entities. we use these to ride trough the void and to create husks.

just make all orb waves unique. even parry and shield

each coordinate on void grid changes the sound. use all numbers avaiable to asign sounds. underwater noises. orbs stop noise and
ground user experience. keys dont need to be always cap, forget about maping all that just use all keys available.play with fonts
the void is a saturated place. depict this. a command to adequate to sound in a specific place(mute sound)

*/

//Forget all this. This is a fire wave now. And it will be a stance because we will now use tab to jump between visible stances on the
//screen. A fire wave is a radial pulse that takes entities on a ride. Fire waves purpuse is mainly to displace entities and to explore
//the void. Fire waves will only vanish when the caster entities rides off OR the entity casts an Ice wave.
//Make everything modular. There should be specific commands available for all different stances. ..
//Vessels need a different mechanism to grow bigger. Being able to create Giant Husks by freezing fire waves its cool, ok so maybe
//we should be able to displace freely while inside a husk, with a center cross.
//When we freeze a flame, husks can trap memories that were manifestating inside the flame radius.
//Husks will now be akin to isles. These places can be strngthened with ice and will acumulate memories.
//We can also write scripts to control these memories as well. A place to learn. Husks are somewhat protected from outside hostiles if any.
//Vessels can get inside husks.
//To create a vessel, a husk must contain one single entity. And this entity needs to play a script with the instruction /vessel?
//vessels can create special waves to interact with all other prims.

We should make json objects to be downloadable with a button just like with
upload buttons

so all txt memories can be comanded to behave in specific ways. Once an Orb is
not needed anymore its escence can be absorbed. Entities can increase Orb
memory stacks...


//.. now we will have many on screen if we want because txt memories will be independant
//Ok so we want this command to be available from any stance, but will require a few modifications.
//if user stance is undefined, user can simply press Enter and type a line, this line will become the txt new name.
//user will change stance and we will now be in editor mode.
//We can change the location of the text using the prim position offset as refference, and we can also move the memory itself
//casting displacement command on the txt stance.
//!!!!!!!!!!!!!
//these commands are mostly deprecated now. Because we want to use general commands to manipulate memories in stance
//we will use .name:new name to change the orb memory name of any memory, we
will use .vanish to absorb the memory?,
//we will use .displace to move the orb offset around when inside a Husk?... Because we shouldnt be able to move memory orbs
//while in the void.. or maybe we should but very slowly.. and when inside a
Husk just a bit faster..?
//.. maybe Orbs should naturally orbit towards Husks. And once inside a Husk , they slowly float around aimlessly when not
//being edited... that l be funny
//.x:num  ,  .y:num ,  .r.. ,  .g.. , .b.. , .a.. , .layer.. . All these commands should affect memories frames or lines properties
//.next , .prev , .beat:num , .chord:num
//.anchor Makes the orb memory stay put(only works while inside a Husk)
//.run Test run... or maybe we want orb memories to always run?
.open  , .close . We can leave memories opened and running or just closed. or open and not running.
//we can place memories in the same coordinate no problem. to run on top of each other and see how would that look like
//if vessels used them in synch with other memories.
//.. we should actually be able to start test runs in synch with other memories to see how it would look like when vessels
//play scripts
//THIS is what we want, we want Husks to be playgrounds for animation sequences.
//.synch:num
//ok so what if we actually could just .load.img or .load.audio into an orb with txt already..? no lets keep orb memory types
//independently.
//so the .load.img command should besides loading the image into sunya, create the img orb and open it right away.
//same with .load.audio... no
//Pay atention to loading coordinates. We dont want to use x and y offsets to extract the position of the image, but we want
//a mirror near the orb to see the position of the image we are extracting. We should just use x0 y0 to extract.
//what about .osc..? 
//maybe we should be able to create tones directly!! yeah yeah.. .osc:freq Creates an oscilator Orb which starts running right away
//we can then .gain  , .freq  ,  .name  ,  .beat ,  .chord , ... so the tune
will read an array of changes directly, just like any
//other custom_a system... but wait sound cant use sunya heartbeats.. we need
to work with miliseconds. .. well we just asign changes in the oscilator using
milliseconds instead. no big deal
We can just write away tunes, even in the void. rogue memories with no containment should spread the sound
//at a fixed radius value.. the size of a user screen aprox. But when these tunes or audio memories are inside a Husk or a vessel
//then we can adjust the area of influence.
			//
TEXT
//So what about edit feedback? What is an edit feedback really? is it a txt
memory on its own? thats convoluted.?
//but we need to be able to see some feedback when editing a memory .. maybe the orb could emit the feed data when being
//edited but the entity could use a special set of states to see it? kinda like eyelids , pupils and k_feed.. e_feed
//and maybe we use .displace to actually move around this e_feed .? just like we should be able to move around a k_feed
//when there are symbols in the k_feed txt? that l be neat and consistent..?
hmm no
we want commands to be able to dump data into a txt orb.. !!!
so the input element maybe needs a counterpart, output, which can also be 
redirected using scripts OR txt orbs commands(configurations?). yes this.
The idea of INPUT and OUPUT is clean and versatile.
So after Enter, we create a packet that holds the txt value, and store it on
all.c_input
And when we want to return some data from a function, operation or command, we
place the data in another array to be evaluated by active listeners.
all.c_output
commands are stored on
all.com_a.. need a better name

So orb txts could have configuration parameters to behave in certain ways.
.limitL		number of last lines it will always print even on new text arrival
We are going to give text orbs some functionality but scripts will have a few
more capabilities
We can make a txt listen to a source nearby, and even react to other orb txts,
but this is a script thing.
so entities have output and input.
Input is the message on the input box, output is the
data returned by commands.
When we are editing , eveytime we call a command to change something , an
output is returned.
output packages contain txt, beats, and line requested?
because sometimes we want an output to always go into a specific line and
replace it. the edit feedback for example

should we be able to make a text orb work like an independant stream maybe?
yes
...
we want txt orbs to do 3 specific things... or maybe these 2..
1 Just print a number of lines, vibe with custom_a for a while , and then
vanish. Maybe they could listen to entity input or other txt orbs in
proximity..
If a txt is in loop, it will just repeat the beats. All memories should do
this.
2 Print data coming from specified sources. store it, but also, keep printing
the last (number) lines only.
Selecting
We entities can select elements to stance. Fire, Void, Orb, Vessel
Special keys will do different things acording to stance.
Fire
To create a Firewave we type in the command .fire
Arrows allow user to displace trough a firewave rim using Left and Right



//so when stance is vessel, we can just .open.nameofmemory to start editing.

//So memories could actually be geometrically positioned too.? no just place
them inside husks and acomodate positions using cursor .yes
//Remember we want animations offset to adapt with scripts instructions. When we create memory animations we dont mess around
//with offsets because we use the orb center as refference.
//Vessels locate all their memories in the center but can project the animations anywhere inside their field.
//Orbs on their own can only project from their centers because they dont have a field but we can adjust the orb prim position
//so we can see how it would look like in synch with other animations.
			//
file management. we want to store file buffers somewhere else, not directly on
orb memories. .load.image  , .load.audio  ,  and we should be able to list all
files currently buffered in the browser. We want users to have control over
their browser activity. .files  should return a list of currently buffered
files and print it on a new txt memory to be inmediately visible.
so we do:
.file:name of file  , and this would open the corresponding editor to work
with the file.

would be cool to just type in something and press enter, and just copy the
symbols into the input inmediately to finish . mayb implement this

Thinking about making zones where memories dust acumulate, more like a gas...
maybe very far downwards on last sunya depth.. just an idea.

ok data structure. we got:
entities
memory orbs
structures
states
vessels

so make it that, entities can consume orbs to "delete " them but it stacks.
klike karma point. entities need to live with the fact that they have consumed
a memory and this has an effect on the entity
If left alone in the void, the memory is absorbed by the void, having a
different effect.

entities should be able to customize their input appearance

Lets fast repeat commands. Firewaves. And set initial radius always to 1. Add
white and a pause so we can charge up Fire.
We also want to see the charger counter going up and down from fires and husks
..Maybe feedback can handle that

we want to stop moving when we casting fire
and we want to define ice and fire interaction
Maybe we want to absorb fire waves by husk intensity
maybe paint fire blue or white or purple and burn the husk a bit using fire
intensity

We should not be able to cast fire inside a husk probably..

Tab could simply ask for memories on Fire. An array to contain all memories
directions . Every time we call Tab, we start looking from the current index
of the stance. Tab left takes us to the prev memory, Tab right to the next on
in the array.
so the structure keeps an array with {id:id , ent:[]} , for each memory inside
the Husk. We match id and do whatever we want everytime. 






//WOA NEW F SYSTEM

So instead of moving, we allocate space. Every space allocated is specific for creator entity control.
Cursor colors is customizable. input will have the same color, orb txt prim center
is a point with the entity colors when is selected. memories have 2 modes, stream and edit.
We can also play a script and watch it execute in real time, we can also modify(edit) a script while its running.

 just realized something. So keys will now hold script creation and running. It makes sense to just make it like this
Arrows and other keys simply call an instruction with many commands. a script. Tab calls a set of intructions
Focus on txt. highlight matching current id and play a focus script So we run a script with a key press. Special keys are mapped to
special default scripts. one script to attach memories around the entity cursor...

Would be interesting to aislate a piece of void surrounded by allocated space!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

so all commands now arise from a container / .
If entity calls './' from the void, it returns all void containers.. no wait.. keep this idea but actually..
./	returns all directories in the Entity.
./orbs	returns all orbs in the Entity doMain
If entity calls '..', it will return all possible commands that can be called from this directory(and by default print them on a stream)
We could '.command?' adding a question mark at the end to print a description of the command.
We can create a memory space with allocm that starts to grow. this is our ship, allocated space. A space without all the scripts of the void
, where we can start from zero. Its a circle. its a primordial command. once run, it creates and adds 1 radius to itself. malloc removes
one radius.
these commands need to run from an entity soul.? ell entities start in the center with 1 pixel radius. entities grow using allocm
and shrink using malloc. entities create orbs using memory. In order to create orbs, entities first need to allocate memory by growing.

So. Entities. these have a default script to process input. They create and transform memories using commands.
all memories are boxes with data which respond to commands. each box uses memory and each box inside other box uses memory as well
to get memory, an entity needs to expand its domain by defragmenting the void. an entity domain is depicted by a circle path
An entity can easily travel trough its domain using the grid x y 
.commands Are procesed by the domain by default. we can do '[orb].command' if we want a specific memory to run a command
[tag] . We can asign any combination of words or numbers inside brackets to create an orb wearing that name. If the name already
exists then its not created, but will still run a command.
Nameless memories will return their id instead of their name when requested
#100>>[txt1]/posX will create a memory orb and position it +100x pixels from the entity center. if the memory doesnt exist already
We use '#' to pass on literals into containers.

entities are structures that proyect graphics and also create orbs
memory orbs are structures that proyect graphics as well.
We cant focus on a line and call it a stance, so we clearly need to be able to focus on things that are not defined as 'stance'
A memory is a stance that can execute exclusive commands. We can select a memory and run commands , would be equivalent to
[memory id or name].command
If we are on entity stance, we cant run .edit because this is a memory exclusive command. We should previously stanciate the target orb
and then we can run a memory command. Commands need to be called from proper directory.
We can focus the screen on pathcs using their coordinates,  we can find all graphics coordinates in memories.
Arrows control the cursor. WHile in void, arrows dont do anything. In allocated space, entity can freely
displace using cursor. We can also grab memories using cursor when we instruct a memory to do so. We can drag around the memory location.
We can instruct a memory and only a memory to follow the entity from a fixed position.
[orb].follow , .unfollow
Memory orbs can store data. We access data like this;
[orb]/databox
(we are fusing all into one single process)
Orbs also have special directories with values that will determine the orb behavior.
We can request from or store data in orbs directories.
[orb1]/box1>>[orb2]/box2
When the orb is configured to run a text, it will have a directory with the corresponding tag. If the orb is configured to run an image
it will have another tag. [orb]/is . 'txt' , 'img'
Text orbs have lines. And lines have beats. [orb]/line/beat .We access these by number. [orb]/4/3
Img orbs have frames. [orb]/frame . We can access frames by number . [orb]/5
Frames and Beats store animation changes. /x , /y , /r , /g , /b , /a , /w , /h, 
We use commands on these data boxes to call functions that manage animations using states.
We can instruct a txt orb to run in stream mode or edit mode .Each modality accepts different commands.
A stream is not able to play as a script, but in edit mode, we can also play the txt as a script in real time.
Errors will change lines beats to create feedback for entities.
[orb].stream	The orb produces and manages a stream of words using a container and the input data signals aimed at it
		A determined number of lines following last one is displayed. Will print input of an entity that has selected it
		or another memory pushing data into it trough an instruction
[orb].edit	The orb will now display all lines and accept more commands to modify its data. We will now be able to also see line numbers
		and feedback for the text animations. We can also play a script and edit it in real time.
[orb].nLine	Selects next data line
[orb].pLine	Selects previus data line

[orb]/Dlimit	Holds the stream Display limit.

[orb].play	The orb executes instructions written in the container.
!!!!!!!!!!!!!!!!!!!!
So we could simply treat each line and custom instructions as data. we say
[orb]/line/beat				Returns beat in a line.
[orb]/line/beat/y			Returns y value. 
#explicit new value>>[orb]/line/beat/y	So this places the value on the left, into the container on the right.
[orb]					Returns all data lines stored in the orb. Returns an output signal with multiple lines
					By default it produces an orb to hold all lines but we can also dump all lines into another orb
[orb]/line number			Returns the data in the line by number
We can manipulate data easily using the sinthax
[orb1]/data>>[orb2]/data/data
We can select a line and a beat by calling commands on boxes directly

Lines can be writen directly to become frames instructions for Image edits. !!
#new value>>[orb]/frame number/x	Just like we do with beats on text but we skip the 'line' container
We can call random values in a range
#..12-45
A memory can be asigned a file previously loaded to work with it.
These commands create directories in the orb to hold data concerning the files the orb wants to manipulate.
[orb].loadimg
[orb].loadaudio
We can then just run img to call the proper editor interface to start working with the file
[orb].img	Manages all states to run the img editor mode. Once finished editing, it returns all instructions as lines into
		a txt to the  /frames directory. Just another data box we can work with.
[orb]/frames ..?
Frames run in sequence just like beats.. when we play a script, all lines are
executed once per heartbeat. Frames, they are executed one per hearbeat , in sequence , until no more frames to read.

If we access an orb directory by number it means we are working with lines.
[orb]/5  , on its own, it outputs the content of line 5. We can make operations using this value, if so then it doesnt produce
an output signal. A line could be anything. We can use a line to rewrite another memory in real time.
[orb].audio	Audio editor

PLAY
....ok we need to consider this play system again..
Its not very good because we want to play the lines sequentially, each line holding a command, we cant expect a line inside the script
to keep track of the script. Yeah change this. ok here is an idea: 
/orb/run	Value inside this dir determines orb activity
If run='txt', orb will read data lines from /start to /end and execute them as command Entries from the orb stance
If run='image' , orb will use datalines from /start to /end to update beats on an image state and create graphics.
if run='...'
or instead of using /start and /end, we could use one value /Beat , which will be incremented once per heartbeat as long as value
on /run is 'txt' or 'image' . once value reaches the end of datalines, it will restart the value in /Beat and start all over again
It we change the value of /Beat in the middle of a run, it will simply skip to the new value in /Beat
...
if run='audio', orb uses instructions on datalines to play the audio
if run='osc', uses instructions on datalines to play an oscillator.
Run
Ok lets review how it will go..
orbs have data lines. An array to hold lines from 0 to end. Lines can be executed. We can execute them as command entries, or as
input.
Lines Graphics
Each line is an object: {txt:'',B:0, beats:[]} . Lines print themselves using beats at every heartbeat. We can access lines txt content
simply by doing /orb/1..2..3 the line number, and we can also access beats at any line we want doing /orb/1/1..2.. the beat number.
and we can access property at each beat /orb/2/4/r..g..b..a
Now these are data orbs. graphic orbs have a slightly different structure. We want graphic beats to be as close as global as possible
so we keep the graphic beats right next to /orb. so we have /orb/gbeats now. /orb/0 access to the first image beat and so on..
/orb/3/x access the x value on the beat 3 of the graphic. ..... thats one idea
Other idea... better imo
We use these same data orbs but now, but when we 'run' them , we feed every dataline into a graphic state. effectively using
the orb 'input' to feed its own /run dir... maybe /img.. could literally hold the state. so we could access the state in real time.
So if /orb/run = 'img' , it will maintain an image state to be updated by its datalines on everyhearbeat
in this way we can work directly on the lines using the beat format . [220,'x', 110,'y'..]
Ok makes sense, so how do we control the graphics calls? a normal command? or a placement command?
.. i think placement commands make more sense. we want orbs to be able to run themselves from their own lines.
We could simply manage L, the currently executing line. This L value would increase always towards the end of datalines on every
heartbeat but only when /orb/run = 'once' or 'loop' . Normally, /orb/run value sits on 'off'.. hmm. This might be it
Ilike the idea of being able to manage frames directly from datalines using the beat format
/orb/seL	The currently selected line number. on edit mode?.. should be Sel
/orb/L		returns the current line number of the instruction executing at any moment
/orb/mS		returns the number of miliseconds playing the audio
/orb/4/B 	returns the current beat running at any moment in line 4..
/orb/run	'once', 'loop', 'off'


[orb1]/2>>[orb2]/newL 	Adds a new line of data into the container. We could also push into a beat [orb1]/5>>[orb2]/4/3
[o1]/6>>[o2]/2		Copies the line 6 of o1 into the line 2 of o2
[orb]/seL		returns a number  which is the currently selected line.? why not the line itself?
We can copy data orbs easily. We can copy all orb at once into a new orb, we can copy a line into another line in another orb
And we can copy beats into other lines or into other beats using '>>' sinthax
[orb]/Last , [orb]/5/Last	Access the last beat or the last line
[orb]/0.. /1 .. /2 .. etc	To access line by number.

Got it. Ok so by default, all data retrieving commands return a line or many lines. Default behavior lives in the entity directory
and it can also be modified because its a script.
by default we can print the data in a new stream near the entity.
If stream doesnt exist already, it creates one using Usignature beat and set it to follow the entity.

so instead of fire, we call, .alloc .malloc  . Alloc is just like fire, we ride the rim of an expanding circle. This circle
is claimed space for the user. Memories created inside wont be corrupted anymore by the Void noise. We stop allocating calling
.malloc. If .malloc value is negative, circle starts decreasing its size..?

Allocated space is a vessel. vessels have points, angle rim and center. If no '/' is specified, then current stance is assumed.
...not a vessel, just a circle?

We can access the input container to work with it. This idea is good.
/input		Returns the input line at any moment. This an orb exclusive instruction. As long as the orb is playing, it will read
		input and treat it just like any other line of data
/output		So while this line is running on an orb, it will take the output from its own commands and treat it just like a
		data line or multiple data lines.... but how this doesnt make sense

To write an entity call command from a script we must type in '/' before the
dot. /.allocm
If we want to call any command from the prompt, we must precede it with a dot '.'
.allocm(free space)	Allocates memory into the void so its aligned and still. Restrains Void activity
			.allocm will increase allocated space radius by 1 every time its called.
.malloc(corrupt space)	Removes chains and react to the Void signals.
			.malloc reduces allocated space radius by 1 everytime its called.
So the entity is just like a memory... We can just change these values to change the entity location.
/posX and Y Keep track of the translate values in the canvas. We store the coordinates to locate entity screen center.
/posX	Returns the entity position. 
/posY	..same
The entity object has special containers which the program uses so if users modify these carelessly then the entity
structure might not work and the user would not be able to do anything.
/stance		Returns the current stance. Placing a new value here will change the stance. This means. the [] that goes
		behind the command line... hmmmmmmm
[orb]>>/stance	Makes orb the stance. We can now access data or run commands on this stance.?
... why would we do this when we can simply run a command from the orb memory already..?
Stances are just like directories..

[orb].vessel	Put all memories in the center of the allocated space and
		enter radiant mode ?

Arrows work differently depending on entity being on a point or on the rim? Maybe a command to surf on circle states. Or contorns
In a path. We could draw a path and move trough it using arrows.. Am trying to break it all down into simple commands to do things
we dont want to make all the calculations to make x y coordinates match a position on the radius of a circle since we could just
use .angle.... /angle
/angle		The angle of the entity regarding rim surfing.
.forward  ,  .backwards ..?
Or we could do
.contour  , .cursor 	To toggle between displace modes. An entity command


Sunya Globals
... 
const Uname = '?';
const Uid = 0;
const doMain = {} //a special circle state.
const Mcounter = 1;	The number of allocated space in radius 
const Usignat = [] 	A box to customize entity control structures. its a beat.
const staNce = 'Void';	The entity current stance. 'MSpace', 'Orb' ,  ??
const M = [];	Allocated memory space can contain memory orbs. All entity orbs are stored in here.
const WM = [];	Other memories?
//local files
const LImg = []; //an array to hold all buffered images
const LAudio = [] //holds all local loaded audio
....so maybe just make one const U and make all these the entity properties




Sunya Commands Structure ... what if just use '/' instead of '[]'
A 'directory' is a stance to cast commands. / Is the entity(user) directory, before this directory comes Void, but we still dont have access
on early game.
We use the prompt to create data lines. Normal lines wich dont start with a '.' are processed as Input by all the elements that listen
to it. The entity default behavior is producing a stream to depict the data line just created.
But when we type in a dot before the line, the system pick it up as a .command   . Commands are keywords that follow after an initial dot.
Entity commands keywords:
.allocm  , .malloc , .. . . . ....................
++>>/MSpace , -->>/MSpace   ...... what about +++>> .. -->>>
------------------------------------+++++++++++++++++++++++++++++++++++++++++
>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<
--->>>+++>>>--->>>+++>>>--->>>+++>>>
.type: , I think we might use .type: 
Orb commands keywords:
.follow , .edit , .loadimage , .loadaudio, .stream, .play, ............
++>>/follow , ++>>/print , ++>>/run

We cast commands on a stance. A second form , the data retrieving sinthax is used to modify values from a stance properties.
We can print out data from the stance itself and its properties. To simply print all properties in a stance we run:
./
This command will return one data line for each stance property access. The entity structure properties look like this:
/entry		A value that will depend on the last entry in the prompt. orb exclusive i think
/in		A value that will depend on the las input in the prompt.
/out		A value returned by a stance retrieve command.
/ins		A script to determine what to do with the entity input
/outs		A script to determine what to do with the entity output after data retrieiving commands.
We use /~ to access the entity Stance.
Entity stance has a directory that can take a line and use it to name a new Orb . /@  . 
/~/@
/name		The entity name
/id		The entity birthdate
/dsignat	Entity beats for default data lines
/msignat	Entity beats for memory space
/orbs		Holds all memories in the entity domain. Return all orbs name formated with '/'
/files		Access all currently loaded files in the system by name. Returns a list of file names.
/eX		Entity location X used by grid displace mode
/eY		Entity location Y used by grid displace mode
/msX		memspace X
/msY		memspace Y
/msRad		memspace radius
/font		The signature font. we dont want to keep fonts on signature object
/angle		Entity angle when displacing in surf mode. from 0 to 6.2
/disMode	Toggle displace mode
/Mspace		Holds the beats for the memory allocating space depiction.
/Mcounter	Holds the maximum radius of allocated space achieved
/skeys		Holds all shortcuts.



SINTHAX
Ok we are doing sinthax again.
When we are on chat box, we can simply do .command to run a command from the entity since this is our directory. Before entity comes Void.
But if we want to run a command of entity from a script we need to write /.command , we couldnt write .commands in a txt because it
would cast the command instead of writing it down so a simple solution is using '/' What happens when we play a text with no instructions?
Maybe the orb could emit an input event for each line. we could write;
-------
Say this at every heartbeat.
/.play... dot notation ?.. why not just  #once>>/run ....
Supress all /orb.command sinthax , we dont need it. We can simply use /keyword>>/container if we want to perform an operation on
a container
and how about a /toggle keyword, to just toggle between possible values
on a special keyword container /toggle>>/DisMode
Because special containers will only work with certan values or certain range of values. We probably want to mess around with possible
options. We could apply an interpolarity function here. Also. How about running specific containers .. hmm wait..
INTERPOLARITY! thank you radu :)
If we +>>/  ,  we get to change the selected line . on the dataline container

if we ->>/kw, we get to change the keyword polarity. YES this is it
toggle up and down work as line selector, or as key value modifiers. They will work differently acording to where do they go
+>> , ->> Toggle Symbols . examples:
+>>/~/angle	Increases the angle
->>/		Selects the previous dataline in the container.
+>>/mS , /r , /L
We can fast repeat Toggle operations. Once per heartbeat max. 
Leaving a memory self running one single command is also a very interesting aproach.
++>>/Mspace
We can also create a very attentive orb listenner that wont skip a heartbeat
/orb/in>>/
Or we can make things spin around
++>>/angle
How about many color changes at once
+>>/r		+>>/g		+>>/b		+>>/a
The Benefits Of Having Multiple Orbs In Synch
Both entities and orbs are limited to execute one command per heartbeat. We can perform beyond memory orb limitations.
We can apply random polarity with the sinthax: '..12-45'  .Its 2 dots, and 2 numbers separated by '-'
..1-255>>/3/3/r
..consider applying other functions like this. radu points to a page on the net let me see if i can catch that

Ok so datalines are always printing.. arent they. /print controls this. +>>/print Toggles between print possible values
'stream'
.. We want a stream mode to print the last line always and show a limited number of lines and maybe follow around the entity
While streaming we cant select lines or modify them. We can also limit how many lines of data the container will accept.
'static'
And we want static display all datalines in the container and watch them change colors when they are running something.
We will now move the screen focusing always the selected line and the lines will respond to more commands now.
/dsignat Will keep the beats of the datalines we produce on the Entry.

--------
Orb Structure
/orb		returns data lines decribing all orbs properties access.
/orb/seL	The currently selected line number. works on containers... ++>>/orb/seL Line selector
/orb/L		returns and determines the current line number of the instruction running at any moment  	/run . ++>> 'once','loop','off'
/orb/F		returns and determines the current image frame drawing	 					/draw
/orb/mS		returns and determines the number of miliseconds playing the audio  				/play
/orb/4/B 	returns and determines the current beat running at any moment in line 4..  			/print
/oscillate? what about oscillators? /freq /waveform /gain
There is also,
/orb/data					return all datalines in a multiliner
/orb/0,1,2,3..					return the data line by number
/orb/0,1,2,3../0,1,2,3..			returns beat of line by number
/orb/0,1,2../0,1,2../r, g, b, a, font, align..	returns beat changes to the animation

If we dont provide '>>' on a retrieving command, the result will use Eouts inmediately.
Eouts is a script that manages outputs by default. by default we want to take these outputs , and print them
on a specific memory always. If the doesnt exist, we create it first

So maybe orbs can have types . Orbs for lines, orbs for frames, and orb for other things, audio, miliseconds..
I think we need to build the structures now.
SUNYA STRUCTURE
Orbs:[]
//Orbs2:[]
Framesl1:[]
Framesl2:[]
Framesl3:[]
Files:[]
E:{
	name:'Kaozzai', X:0, Y:0, Ang:0,
	Entry:' ', Ein:' ', Eout:' ', stancE:'~', 
}

Elid:{
	B:0, layer:0,
	beats:[
		//['r',1,'g',1,'b',1,'a',0.2,'w',window.innerWidth,'h',window.innerHeight]
	],
	state:{
		r:1, g:1, b:1, a:0.2, x:E.X-window.innerWidth, y:E.Y-window.innerHeight, is:'rect',
		w:window.innerWidth, h:window.innerHeight,
		inside:'filled'
	}
}
EkeyS = [
	{name:"a", key:"a", com1:".allocm"},
	{name:"ñ", key:"ñ", com1:".malloc"},
	//editor tests
	{name:"next line", key:"n", com1:".linedown"},
	{name:"prev line", key:"b", com1:".lineup"},
	{name:"beats", key:"t", com1:".type:.beats:"},
	{name:"beat", key:"y", com1:".type:.beat:"},
	{name:"beatup", key:"m", com1:".beatup"},
	{name:"beatdown", key:"v", com1:".beatdown"}
]

//this one look like a data line but requires a circle state
Mspace:{
	B:0, layer:0,
	beats:[										// /msignat
		['r',200,'g',205,'b',200,'a',0.7],
		['r',230,'g',255,'b',230,'a',0.8,'x',E.X,'y',E.Y,'radius',1]
	],
	state:{
		r:230, g:230, b:230, a:0.8, x:E.X, y:E.Y, radius:1, is:'circle',		// /domain?
		inside:'empty'
	}
}

!!!!!!!!!
We want to use orbs datalines for everything but for lines beats. Lines beats can go inside lines
a dataline is data, a state, beats[] and B to keep the beat

orb:{ //more like dataOrb
	name:'leorb'
	run: //['once','loop','off'], //3 possible values on both here
	print: //['stream','static','off'] , 
	follow: //['~'],
	L:1, // possible values: from 1 to the length of data array
	seL: //possible values: same as L
	data:[
		//we keep beats on each line.. We update lines graphics by calling beatUp on each line
		{txt:'Hello', beats:[], B:0, state:{}}, //data line
		{txt:'Hello', beats:[], B:0, state:{}} //data line
	]
}
imgData:{
	F:1, Draw:'off', name:'Anem', file:'...',
	f:[
		[]	
	]
	state:{

	}
}
audioData


////////////////?
lineOrb:{
	txt:'data',
	beats:[
		[],[],[]
	]	
}
////////////////?



but scripts call all commands at once when they execute ? or it calls one command per heartbeat until no more commands.. ?
.. i think calling one command per heartbeat has a lovely appealing. Also i think its better for performance of the program overall..
Yes we want to cue commands but we want to run one command at a time. If 2 orbs both are running a script, we run one after the other?..
.. we run one command per orb max per hearbeat. this sounds reasonable. Because if there where no limit as to the number of commands a
script can hold, it could easily get stuck by simply making a gigantic script, would crush the program.
We dont want too many operations in one heartbeat. So yeah we should just make scripts run commands sequentially, one per heartbeat.
ok let me reconsiderate. Maybe running all commands in a script at once is also doable... no i don think its a great idea
So we could make a script repeat itself by adding an instruction at the end so it selfs cue its execution.
/orb.play	Adds the script to the execution cue to be run on next iteration
We can call any orb and as many as we want to play from a single script but we call sequentially one after the other.
/o1.play
/o2.play ...

Conditions and Operations
We can add and substract...? not sure if we need this lol but maybe..
also not sure if we need to be able to compare now lol yeah maybe we do need that . This is starting to look very functional..
/orb1/1=/orb2/1{}/orb3.play		We just run the instruction on the right side when when condition is true..

so now am thinking orbs could call animf on them directly and just use their directories data to update animations.
because having states apart from the orb implies many search loops... yeah i think this is important hold that thought
just make a small object and push that into draw cue.. then flush the draw cue arrays

How about commands cue. Because eventually orb will compete for which command is executed first given a certain heartbeat.. wont they
If so, then one orb positioned before in the array index might imply certain advantage? if 2 orbs issue a command on the same heart beat
we cant just arbitrarely decide which one is executed first by index order... we  need a speed parameter. so orbs and entities
cue their execution time using a well defined ground. Speed can vary acording to many factors. Orb personal speed, environment effects
....
On the other hand, we could simply make execution order on the same heartbeat meaningless because both commands would be functional and if
they create oposed effects then the result is simply neutral. Its a clash, both commands run , we consider this fact before anything. this
sounds smarter than making commands compete.

Heartbeat
So now we check for entity activity and then orb activity and then void activity probably..
Entity
So we first ask for /entry and annalize it if any. If its just a normal input, we use a default behavior script , if its a command,
we annalize. and run
Then we need to run the entity signature animation so we run animf using the signature structure.
const Usignat = [] 	A box to customize entity control structures. its a beat. And we create a path right there to illustrate
and highlight the current entity control structure form.
If cross mode , then the entity is a dot in the middle of the screen. On surf mode, the entity signature paints all its memory
allocaed space radius. A circle which represents the doMinion of the entity. The Usignature colors go on the rim,
inside is transparent? maybe just empty. 

Orb
A loop to check for all orbs. we need to ask for mode:
If script is txt playing, we run c_com on the current Line /L and then we create a path for every line to be printed acording to mode
so we call animf
If mode is edit, we run trough the lines and create paths to illustrate them by pushing into proper draw cue, same with stream mode.
If script is img playing we run animf on current Frame
If script is audio playing....
Void
...

Command Annalyzer
All data lines fed into this function are already striped of its initial dot. if we have a '=' anywhere in the command,
its a condition lock , so it must have at least 2 '/' more and a '{}' somewhere. Conditional always goes in the left side so
right side might have a '.' . The maximum denominator is '{}' because there can only be 1 of these per line always, so we start here
var com = '/orb1/1=/orb2/4{}/.new'
var FS = com.split('{}');
FS[0] is the condition statement, FS[1] is the statement to run if condition is true. condition always has '=' .. for now so ,
var EQ = FS[0].split('=');
EQ[0] now holds a data retrieving command and EQ[1] also holds a data retrieving command
2 '/' means we are accessing a single line of data. If its a number, then we output the number data line from the orb. if its a
keyword, then we output the key value
3 '/' means we are accessing a beat in the line. its always a number. it returns the whole beat array values explicitly in one line.
4 '/' means we accessing a graphic property of a specific beat and its always a keyword /x , /y , r/  and so on.. it returns the key value
Right side of the First Split is just a normal statement

A dot '.' means we want to call a function on the stance or a property of the stance. Separating using '.' Its the first step for normal
statements. dot notation
var DN = com.split('.');
DN[1] is always a keyword to call a specific command that will do something depending on the stance.
DN[0] Holds access to stance itself or a Stance Access property, we need to split again using '/'
var SA = DN[0].split('/');
A single '/' means we are retrieving all property access from the stance and creating multiple data lines of property access.
2 ,3 and 4 '/' all return values.

A second big divider is '>>' . If there is one, and there can only be one '>>' , it means its a placement data command. so we
do a First Split using '>>'.
var FS = com.split('>>');
FS[0] now holds a data retrieving command and FS[1] holds a data placement request command. /entity or orb name or id/line number/beat num
A single '/' means we are retrieving all property access from the stance so we output lines like '/X' which are paths to the stance
properties. FS[1] must be able to store multilines . This operation is simple, we just copy data from FS[0] into FS[1] location.
FS[1] could be : /orb for multilines only and /orb/number for one line or /orb/linenumber/beatnumber for beats which have a special sinthax
Or /orb/framenumber . 


//PEAK COMMANDS STRUCTURE
When we type in, if the entry has no '.' at the beggining, then its an input signal. the data is sent into its structure, and other
orbs can listen and read it and process it....
Ok but input will go to a different place acording to stance.... okokokoko
If stance is '~' , input goes into Eins
If stance is an orb, and user types in a non command, data goes into orb data line, to last line or selected line depending on print
If stance is '~', output of a retrieving command by default goes into Eouts? 
If stance is an orb, and user types in a retrieving command by default goes into Eouts?
By default, entities use a script to process input signals and create a memory to store and display the input data in a stream.
Maybe Eins and Eouts should check Ein and Eout after all orbs have been checked

.commands?
 call functions that act upon containers... do we need .commands ?
Data retrieving commands return output signals which can also be read by other orbs and processed as well.
//ok lets write down all possible structures to have a really solid grasp on where to start annalizing the command. we are omiting
//the initial dot for clarity. initial dot is only used by User casting commands from a stance entry directly and its equivalent to say
// '/' on a script. We cant write '.something' on a dataline because the Entry registers a command when we place a dot in the beggining
//of User(Entity) input.
/*
General Structure
Directories

Containers
Containers hold datalines that perform differently acording to their structure.
To edit datalines stored on containers we use edit commands:
/delete , /copy , /seL
Normal lines have no special format. Command statements have the command sinthax. Beat lines have a different format and Audio data
also has a specific format. All containers react to edit commands. Lines can be selected and manipulated to customize their operations.
....
PEAK
Alright. Forget about /lines , /frames and what not. Data lines live in / and /orbname. These are directories. Changing stance changes
the root directory.
All lines have beats and states and counters to illustrate their symbols.. symUp
but apart from that, we can run lines.
When we run lines, if they are formatted properly, they can perform Instructions and cast commands.. comUp
or they can Animate images... animUp
or play audio in a specific way.. audioUp

Keywords
Hold values that have a determined range of operation. Might be numbers or words. They return their value on retrieve and create an
output signal. Changing values of keywords create different effects on their preceding structures.
examples: /X , /seL , /L , /run , /print  , /data , /1..2..3..4

Commands
We always use these keywords on specific containers to act upon. They dont return values but perform specific tasks.
examples: /follow , /delete , /copy . We call commands on structures like this: /follow>>/orb ... /delete>>/orb/1 ...



/ , /@ , /~ , /kw  ,+>>/,  /orbName  , /lineNumber , 
/orbName/kw or lineNumber , /lineNumber/beatNnumber  ,   		  
/lineN/beatN/param , /orbN/lineN/beatN	, orbN/lineN/kw	  
/orbN/lineN/beatN/param

Sinthax
Any of these structures can be on the left or the right side of '>>', '+', '-', '=', '{}' with a few exceptions
#literal  .  Literals can only be on the left side of '>>'. But they can used like this: /orb/seL+#2 , because we add 2 to /seL
We use literals to change values on specified containers. lines, beats, params or directories
As the arrows imply, '>>', we use this symbol to copy the value retrieved from the left to the right side. example
/orb/4>>/orb/6	This will copy the value of the fourth Data Line in the orb into the sixth dataline in the orb.
Some keywords will return multiliners, not all containers can hold multilines. we can />>/orb  , this will dump all dirs from the current
stance(directory) into the orb in the form of multilines.
A single line has /Beats . Beats are a multiliner, each line printed is a beat instruction in beat format. we can print one specific beat
or we can print all beats with a keyword. Some keywords will create multilines. /Eins , /Outs , /orbName, /~ , /orb/4/Beats
When we place a new value on a dir, it will have an inmediate effect on the stance. Some keywords will create an effect on the target.
/delete>>/orb/3	Will delete the line 3 in the orb. Calling /delete without a target results in no output.
#Jack>>/@	Will create an new orb named Jack. Calling #Jack without a target results in no output.
So calling certain keywords always require a target to do something.
/~/X+#100	This will displace the entity screen 100 pixels to the right.



Special Containers
We might want to edit some special containers on the Entity. We can manage these just the same way we manage Orbs.
/dsignat	Holds beats for entity data signature
/skeys		Holds Shortcut Keys
/kkeys		Holds Keyboard scripts for special key. Space, Tab, Esc etc
/eins		Holds a script to process input with no target on Entity stance
/eouts		Holds a script to process output with no target
/files		Holds 
/mspace		Holds circle structure for memory space

Entity Keywords
Values in these containers affect the entity behavior. Not all are directly accesible.
/stancE		The current stance. Changing this key changes the entity stance
/ein		The value of entity input signal
/eout		The value of entity output signal
/angle		
/font
/eX
/eY
/mX
/mY
/mRad
/disMode	'contour', 'cursor' .To determine how we displace in the memory space
/mcounter

/L	The current dataline running
/run	Manages data command lines on orbs,'once', 'loop', 'off'
/print	Manages data lines graphics, 'stream', 'static'
/draw	Manages instructions for images, 'once', 'loop', 'off'?
/play	Manages instructions for audio, 'once', 'loop', 'stop'?
/follow	If it holds an orb or entity name, it will follow and synch its position with it.

We access lines in these containers by their number /container/1..2..3..4.. And we modify them using the same commands we use on datalines
frames, beats , tones and audio take only special lines that have coherent sinthax, if lines fed are not properly structured then
the frame or beat will throw error and not print properly.
Datalines Editor Commands Keywords . Deck . These keywords act on containers only.

/delete		Removes a data line called on /delete>>/orb/2 . Can delete multiple lines /delete>>/orb/data
/copy		Puts the value of data in the chat input for user to modify
/op		Toggle for values 'replace' , 'insert' to perform operation using input signal on the data
/last
/seL

We select a line using /seL . The number we place in this container determines the line we have selected.
The /op key determines what we do with the input acting on the selected line
We delete a dataline permanently and we supress its position with the /delete>> instruction.
We can copy the value of any dataline selected into the chat input like this:  /orb/3>>/copy
/orb/last>>/	Will return a number which corresponds to the last dataline in the orb or special container.
#2>>/orb/seL	Modifying /seL value here means that the currently selected line will now be 2. We select lines to edit them.
/orb/seL+#1 , /orb/seL-#1	Selects the next line or the previous line in the container.
We can also toggle on seL like this
+>>/seL	 , ->>/seL 

If entity retrieves from entity with '.' , we feed output into Eouts.
If e retrieves from orb with '/', we feed Eout into Eouts
If orb retrieves from ent with '/~', we feed orb out. Same with /orb retrieving from another /orb, just put into /orb/out

So what happens when we run a toggle command on a directory? .. nothing really. Cant think about anything that would make sense.
+>>/  .. Maybe we could simply change stance.. no.. thats not precise. to change stance we do : +>>/stancE



......................

so by default , Eins creates a txtOrb on stream mode print. max 6 lines
Eouts creates a txtOrb on static mode print
a keyword to delete all lines in a container at once
a keyword to erase a memory orb
'r',200 .. and we just update a specific beat to depict line activity
we could scan request from graphic states
graphics draw, audio plays, lines run
a txtOrb has lines. we manage lines execution with L, and run. 
and manage visibility of lines with print. if running, print briefly paints
the executing
line with the entity signature
every line has data, a state, B, and beats
when a line changes, we update all lines to adapt to possible new positioning
but when no changes, we simply beat up using print, B, and beats
print manages all lines at once. 
................................



so linking a file to the orb, creates a state to be used. we simply asign a
file name
to /orb/file
An img would create also a single instruction to depict the whole img at once
and hold it
We can now create other orbs to start figuring out what parts of the img we
want to draw
sequentially.. And maybe we can now create orbs to behave in a way that
resembles the old edit system

1 orb to create all neccesary orbs to edit run once. 1 to clear them all up
even itself just
leaving the one orb carrying the edit work
1 orb to hold bg image . 1 orb to illustrate capture. 1 orb to illustrate edit
result. 1 orb to
illustrate an empty rect

px py pw ph need to tranfered to a common center for memories working on the
img..

How else could we edit an img.

so maybe we need rects and circles back... so we can build hit boxes or other
circular movements
we probably also want lines. just building line paths to play ar0und with.
Moving the screen across a path sounds interesting. Audio can also be moved
around and coonected
to other forms, and other orbs. 

we could simply change lines format to indicate how to read data instruction.
orb/form value automatically modifies the state to handle properly formated
data lines
['a',1... , {gain, 1... , /orb ..
Beats could be just like this
['x',230,'y',230,'w',230,'h',340,'px','py','pw','ph']
We can write 
[2]
on beat this means we repeat the last beat 2 times before continuing

dsignat
This container holds beats to be used on all structures created whose beats
havent been specified
Default entity inputs, default memory space, default forms

Audio states are probably going to be very different because sound requires
precise timming.
we are not using heartbeats, we are using miliseconds. audio statements take
their own time to run
}rise:value}start:value}gain:value}end:value}fade:value}

Oscilators also have their own sinthax
{rise:value{gain:value{freq:value{waveform:value{duration:value{fade:value{

//ORB PEAK structure . will start small and add functionality as we add it on top
orb:{
	L:1,  //L keep track of line running
	run:'off', //'repeat', 'loop', 'once'
	print:'static', //'stream', ''
	data:[
		{ //this is the line with its txt and beat structure
			l:'/bleble', lB:1, lbeats:[], lstate:{},
		}
	],

//and here is the optional structure(s) to manage the form created by the line. ..we dont need to have an array for the beat
//we can simply use the txt on data line using L itself also, and just convert to beat and use it to modify the state
//inmediately. fstate. This is good because not even all fstates will have beat structure so we use form value to choose
//the converting function
	//form:'line' , 'circle', 'rectangle', 'image', 'audio', 'oscillator'
	//fstate:{},
	//file:'fname', //if we have a file, then form automatically changes acording to file type
	x:0, y:0
}

B minimum value should be 1, just like L. Its more human readable.

so many properties from orbs structure are only created when we change others.

entity and orbs both have in and out
Ein stores Ent normal input. on entity stance, Eins processes Ein
Eout stores entity ret command with no target  /X . can all keys be
interpolated?
so we want to place Eins and Eouts after orbs activity
what about # do we really need it. i think not
./~/files  Return a list of .... ok we need to build that function
create an array with output messages. Eouts should be able to process
multiliners
/~/out>>/feedout
Would be consistent to feed one line at a time.. but not so sure it Would be
ideal
.. its simple, just push all items on /out into another container

One Step Ahead
The /orb/in instruction locates the orb on Orbs array and asks for its index.
if index is < than listener, it means we can safely ask and work with it.
if index is > , then the listener splices itself out from Orbs and relocates
itself on last place
in the same orb array. L is not increased so when we check again , we read the
/orb/in again
and now we can work with it. So its one little proces to add but this secures
orbs being able to
read other orbs everytime. These listener orbs need to have a single
instruction otherwise, they might
skip a beat.

So orbs being small and performing specific tasks is a good thing. Maybe
certain operations dont
require to spend a turn(beat) like reading a normal line or reading input
maybe? 
Because we will want listeners to at least start a process.....and we could
also
set a line /orb/in>>/ on repeat. repeat makes a script read the same
instruction over and over again
orb/1>>/orb/run . The next line will get repeated and this one doesnt cost a
beat?
Maybe lines that dont cost beats might be colored different on declaration
Orb will repeat the listening line until it catches an input, and only then,
it will execute the
rest of the script... something like that. problem here would be, how orb
instruct itself
to stop repeating and set run to once or loop. we would have to rely on other
orbs instead.
But this is interesting, because thats how we want scripts to work. The whole
system idea
is to make orbs work in harmony. even editing facilitates this work because we
can position
lines spacially. The '=' thing will certainly disrupt this aproach.
working with ins and outs even feels cleaner and more straight forward than
adding conditions..

maybe all commands should create an output apart from creating the effect.
this way its easier
for listeners to react to specific commands?

Big Question
Should we be including '=' and '{}' to allow scripts to ask for conditions, or
we should keep
script system purely in and out oriented.?

Form Scan
A script can detect and grant access to all orbs inside a memory space but
sometimes this
might be overwhelming. Another way to scan for nearby objects is by creating a
form to Scan
radially on a specific point.

Orbs need to be very lightweight

certain commands cancel each other. two 3ntities on a common space can lock in
trying to 3xecute
oposed commands

The most basic domain form is a circle. But some entities can change its
domain form.

The greater the size of a domain, the less intense the entity memories become
The smaller the size, the more intense the memories become

MSpace form


SO follow. How will it work
/~>>/orb/follow		This will lock the orb in a fixed position from the Entity and will follow around the entity when it moves.
/orb>>/orb/follow	This will lock one orb into another orb
/orb>>/~/follow		This will lock entity into an orb focus.

follow command needs to store x and y quantities. how much x and how much y to
arrive at the followed from the following structure.
Follow should only work for directories. that is entities and orbs

SO the thing is. Each command needs to be modular. one com to displace, other to change stance. but we might want to do both at once
using tab, so maybe tab need to run a script, that is, a sequence of few commands.
WE dont want to just modify MSp radius to grow the memory space because it would break the mechanic. so maybe its the same for displacements
Nor entities nor orbs should be able to just say orb.x + 100 in a command, that would break mechanics.
beats for graphics should totally be able to do so on the other hand..... so we can access those like /orb/data/3/3/x
all directories and keys ca be asked for its value. directories simply return a list of keys, keys simply return their values
We cant toggle directories , only keys. /~/stance  , 
/orb/data can store any value. we can access datalines to retrieve or modify their values. and we can use values on datalines to
change keys values. But keys wont accept just any value in order to work properly. All keys can be toggled to explore their possibilities.
But some keys can ONLY be toggled and wont work properly when simply asigned a new value.
/~/msp/x , /y, /rad  cant be modified directly, but only with toggle commands. These keys control the area of Memory Space.
We CAN on the other hand say: /orb/data/5/x>>/orb/data/3/x  To modify the key value of the beat 3 in orb data , this key will accept
a wide range of values. A 100 on x would place the orb controled state 100 pixels to the right of the orb position.
We can modify beats in orb data states or in data lines beats themselves directly
but we cant modify /~/msp/X like this. it would break the mechanics.
Entity visual focus has no limitations inside msp, we can directly asign values that will only work as long as they are inside msp radius.
Orbs can also freely accept values just like entity focus.... ok here is an idea
Entity and Orbs can freely displace inside msp using cursor and surf methods
on 'cursor' mode, we use x and y , on 'surf' mode, we use angle and distance from msp center, its radius...

Am trying to decide if being on an orb stance should accept arrow commands to be moved around.. yes
We want to move memories independently by default. Just make stancE the orb name and arrows will now move it. ok do this now
We can also just move memories around without moving the screen. Yes we need to separate these things.

Many orbs converging in the center, entity reduces msp to a certain size to synch with the memories.
and now all orbs command to displace to a place, moving msp across the void.. kinda cool


Refine.
We want to move by grid and by angle and radius. cursor and rimsurf. Using arrows.
we are close
We need to go back a bit.
/@T text . creates an 'inorb'. An orb that will store data lines.
Sets a prompt. Creator mode. We write by line. We can move all text. We have commands to edit the text.
by default it self names using id. we can rename with a command. Accepts all kinds of input. we can edit all lines beats.
we can use data in lines to modify other lines.

/@SC script
If we write an order. It will execute on loop. 
.follow.... ~/X>>/X,~/Y>>/Y,+100>>/X,+100>>/Y
data and com are two special directories on text orbs. we can open data, com, input, output, frames, oscilator, circle
an orb on input simply channels all user input at any moment and print it on a line.
we can process input on com mode by saying
/in>>/data . This will register all input into data container incesantly .
orbname/out>>/data  .Same as above
We can then open data mode to show all collected data in a stream
We can see all parameters of an orb in real time with the command
/status>>orb2/data
And have orb2 display in real time on out mode
X:123,Y:32,R:1,G:55,B:123,A:1
This is how we display data on all elements.
We can request for specific keys. /X>>orb2/data . And have orb2 display in out mode the value of X of the orb executing the command
data mode lines can also be manipulated or used by other orbs . say orb1 has these 3 lines with numbers:
100
200
33
orb2 can use line 1 data to displace by 100 when it beats
orb1/data/1>>/X
We can change modes on orbs by issuing commands
+>>orb/mode  . To toggle orb modes . 
script mode can play on loop or once, doesnt need to be incesantly running
+>>orb/run  'loop' , 'once' , 'repeat'
orb/play

we can halt commands execution
[230]
We can create conditions?
[orb1/X=orb2/X] If true we continue executing, if false we halt execution

OK . an experience
Noise all around. One button preesed on hold to grow memory space. A circunference that drives away the sound. Leaving user in silence
in the middle of the screen. A cursor point vibing. We can now open the prompt and type in whatever. The words are on the screen, we
ve just created an orb. Every line keeps stacking. We can move the text around with arrows. We can edit the text with commands.
+>>/sel  to toggle between lines selected selected lines change color .
+>>/stance  To toggle between orbs and ~ .
+>>/displace to toggle between displace mode . Arrows behave diferently acording to displace mode
+>>/form  toggle the orb form. in , out, data , script, image, rectangle, circle, oscilator, audio
Script holds lines that execute orders when /orb/play

I need to decide what happens then when we type in normally while on an orb stance on say.. out mode.
. we should be able to type commands directly on the stance selected. The thing is, we want orbs to also accept lines and just store them
.. maybe by default we should just store input on each stance.
So input on '~' simply stores an input signal into ~/in which lasts to the end of the heartbeat.
input while on other orb stance also creates orb/in lasting a heartbeat.
now we can instruct orbs to store input datalines into orb/data or any other container

do we want commands be called using a dot notation from any stance? or we could use '/'... but its nice to have a free prompt. sometimes
we would like to write .something or /something without it being read as a command.. maybe we want specific stances to read input as is
and the rest of the time, prompt is just a command line.. hmmm..
So a command on a data container can instruct to accept a line as is..
input on an orb stance puts value into orb/in 
input on ~ stance puts value into ~/in
We can process these signals by running scripts
.. the problem is dot notation. 
!!!!!!!!!!!!!!!
Maybe we could open two kinds of prompts. in and com . We use enter to cal in prompt
and we use a different key to call com prompt.... that would solve the problem
So from any stance , we can just call one of these prompts. We can run commands directlt on orbs or directly on entity stance
... yes i think this is cleaner than having notation.
So orbs will treat input depending on their own scripts. And we can always just issue commands using com prompt
We can edit a script by first editing a txt and then storing it on orb/script.
OK this is good.
..so orbs have dirs which accept multiple lines to work with
data, script, frames
..and keys which accept only specific words and numbers.
form, X, Y 

orb/in holds input produced on the orb stance for one heartbeat. Its cleared up at the end of it.
commands produce outputs. We direct the output into other orbs and we can process it. All output signals are arrays
containing 1 or more lines of data.
An orb output signal can be accessed with orb/out

orb in 'data' form prints all datalines and these can be edited with specific commands.
orb in 'stream' form can be instructed to hold a max number of lines to display. stream prints cant be edited.
We select what lines stream shows from a given source.
orb/key>>orb/stream
... so the way it may work could be. the dir out just stores the data.



$$$$$$$$$$$$$$$

Orb complete structure access keys

//soul layer
/x , /y, /angle, /rad, /out, /in, /name,  /dismode, /script , /run, /forms //seals

//mind layer
/data, /data/num , /data/num/beats , data/num/num, data/num/num/key, 

//body layer
/imgf , /frames/num, /frames/num/key , /file
/circlef, ...
/rectanglef, ...
/line ...
/sound ... /file

So in forms, we have 1 line for each possible form(active layer). Each line represents an orb aspect which can be activated
or deactivated and even sealed.
Orb internal structure transforms when we change these lines. The soul can control multiple orbs to extend its mind or its body. 

/x and /y
Coordinate used for all orb activities. Serves as refference for the body layer, and the mind layer.
/angle and /rad
These parameters contain location for wheel displacement mode. 
/in and /out
Input data goes in, commands results go out
/name
The word is the directory. 
/script
Stores command lines to be executed in sequence.
/run
How script executes commands contained.
/data
Holds data text lines. Can be edited and its value transferible to any other key or container.
Access data lines by number. /data/3 . If text aspect is on, we can access and rewrite each line beats. /data/3/beats.
/data/3/4/key
/imgf
Holds img frames. Access each frame by number. /imgf/3 .
Access each key on each frame /imgf/3/4/key . x,y,w,h,px,py,pw,ph,a,layer
/circlef
Holds circle frames. Access each frame by number. /circlef/3 .
Access each key on each frame /imgf/3/4/key . x,y,r,g,b,a,radius,inside,layer
/rectanglef
Holds rectangle frames. Access each frame by number. /rectanglef/3 .
Access each key on each frame /rectanglef/3/4/key . x,y,w,h,r,g,b,a,inside,layer
...
/line
/sound
incomplete..

$$$$$$$$$$$$$$$

Orbs will show something acording to its /forms lines values.
text:off/on
circle:off/on
rectangle:off/on
line:off/on
sound:off/on

Each switch make specific keys and directories available. Switching off implies making data unaccesible trough commands.

o:{
	name:'',
	x:0, y:0, angle:0, rad:0, gspeed:1, wspeed:1,
	dismode:'grid', //'wheel'
	i:'', o:[], //in is a keyword..
	run:'once' //'loop', 'repeat'
	script:[],
	//forms:[],
	text:false, circle:false, rectangle:false, line:false, sound:false,
//here comes optional structures.
	//data:[], insertop:'replace/add'
	//imgf:[], imgfile:''
	//circlef:[],
	//rectanglef:[],
	//line:[],
	//sound:[] audiofile:''

}





//however we dont need to find it, we can just ask ? . And now a new symbol. DOT '.' !!!! HE IS BACK
//Typing in a dot as a command, calls the entity cursor on the center of the screen for user to displace entity trough its 
//Memory Space

we can beat any line like this
orb1/data/3/beats>>orb2/data  then we set orb2 set text form on to see the beats. it returns a list of beats with highlight
on current running one.
../beats Returns the current beats on the line. an array with values. thinking about how to highlight efficiently 

We edit some lines to create beats
red:23,g:54,b:..12-45
x:23,y:54
And then we feed a line beats . we can change the number of beats on a line . 
orb1/data>>orb2/data/3/beats  by making data on orb1 have a different number of lines with beats instructions.
a beat fed once stores its beats.


/@C circle
Creates a circle state. Also a prompt. We create changes on the circle with instruction lines
red:23>g:54>b:..12-45>
x:23>y:54>

/@R rectangle
Same

/@OC oscilator
Same

/@AU audio snip
...


ok new edit data controls.
Enter 2 times to put user on input prompt. This input will not be evaluated as a command and it will go into in dir of current stance
orbs have i , entity has Ein.
Orbs evaluate input. orb need to have text aspect activated or wont evaluate at all? Input will go into a dataline determined by
insertop and seL
insertop is the operation we want to perform with the new data arriving and seL is the selected line.
+>>seL on the orb to change the line selected
remove>>seL to remove a line selected
copyin>>seL to copy a line text into the input prompt
copycom>>seL to copy a line into the command prompt
We can always just press ESC to cleat the entry prompt

We want feedback now.. how does it look when we select a line. or when we select a stance. or when we are on commands prompt or input
prompt
All commands need to return an output signal which can be procesed by another orb. This is how we get a solid base for feedback
If entity calls displace left, not only it will perform the operation but also it will return an output indicating what command
has been executed and what did the command return this is important because now orbs can process this. All commands executed by
orbs also need to create an output and put it on orb.o for other orbs to listen and process the information.
An output command return requires the command that called and one item per line after. Because we want multilines outputs to work as well

lets see if its not complicated to just push command, first line, second line and so on..
['command', 'first output','second' ]


1structure, 2function, 3update




!!!!!!!!!
maybe we could ask if and orb first data line matches the commmand thats
retdieving data
so we only update text and dont create whole lines again

MSp . The area where entities have control over data. 

Msp is the entity form. We can grow in area to aquire new memory limits.
if we shrink back, we still retain the memory capacity obtained.
growing and shrinking operations can only be performed by 1 per command, so
if we want to grow or shrink fast we need to synch many orbs to run the same
command at once.

The entity form(Msp) can only be displaced when size is at a specific value.
Moving trough the void has a great memory cost, it requires the net efforth of
many
orbs in synch

as a result, only entities that managed to grow to a certain size and shrinked
back
can cr3ate the conditions to displace trough the void.

Memories can be corrupted. 

When orbs form synchs with entity MSp form we can empower the entity even
further.
The entity wears its memories as its skin and face, a mask for the soul.
Entities are human memories. Orbs are human desires

Combat . 

phones will read pinching out or inwards as an instruction.

ok conditions are. We cant repeat commands on the same line, some keys can
only
be modified by 1. so now we can say
orb/in>>orb2/disleft , +>>orb2/cframe/1/r
or
orb/out>>orb2 ...
orblistener/data/1>>orb2/script/1
okok here is how we could do it

one orb always listenning to target
targetorb/out>>lisorb/data
Outputs always return a packet with strings. first string is the raw command
that
produced the output and each consecutive line is the result. so if we print an
output
it would look like.... wait do we really want this. orb/out probably dont need
to return
the result of the command but only the command itself casted on that
particular loop.
yes probably. so we could simply say
#orbcasting/out>>$
And this would effectively copy cast instantly but we could also evaluate if thats a command we want to copy?

1 disleft	The command that generates an output
2 100			The output value ?
so another orb3 could say
#lisorb/data/1>>$, clear>>lisorb/data
orb3 would now copy and cast on itself the exact command casted by targetorb.
so hashtag operation takes a value and forms a literal command with it. one idea
orb0 could keep an eye on orb1 gspeed and keep orb1 and orb2 at same speed by running on repeat this
orb1/gspeed>>orb2/gspeed

also, when we ask for data lines that dont exist, command is simply ignored
generally, all commands that cant be run, should just be ignored and maybe colored for feedback

certain commands dont care about stance. all displace commands, toggle sinthax
+>> , ->> , disleft, disup... remove , copycom, copyin
these commands only care about right side of '>>'

BIG however
If we wanted the output of some operation to go somewhere we can simply say
orb/key>>orb2/data
So the orb/out key should actually just return the explicit command an orb is executing . This makes by far much more sense.
Because now other orbs could just listen to the orb output to learn what is it doing because it would return the explicit command
Wether its an entry from a user casting from the orb stance, or a script line executing, the output is simply the command
being executed.
[command1, command2, command3]
~/out , orb/out , can only be accesed by others, and it will return the command being called on that heartbeat. !!!!!!!!!!!!!

#cancelled
so hashtag operation takes a value and forms a literal command with it. one idea. would be useful because we might want to use
literal values of data to perform operations .Most keys returning values will allow orbs to use those values to something else
.... but maybe we dont need to do this... let me tell ya what would be better.
We can take a line of data, and place it on  the listener just like this
orb/out>>$/script/last . Boom now we can run the output from the listener. We took a command from the output of a specific orb
and wrote a script line into orbselves with it. simple. We can now just run it ourselves
targetorb/out>>$/script/1  Would place the command from target orb into our first script line.
/out Always returns possible commands running on self $. ... and maybe the value returned....
Ok when we are listening to orb/out what we are really doing is monitor the orb actions. so lets say we are only registering commands
with no '>>' pipeline. It would register commands like; $/key , orb/key, ~/key ... we dont need out for this, we can just grab those
by ourselves. What do we really want from out...? The command/s thats running the orb at any moment. I think this is it.
Lets say we dont need it.
We can monitor any key and/or container values by just saying orb/keyorcontainer>>$/data
but what could we do with these and how would they look like.?
OK SO out is interesting to consider as a stream in time. When no output, then value could be a number to represent a dead beat.
So if we just place the output of an orb into a script of another one, we would bassically link them and make them work in synch.
But the problem is that sometimes we want to change a few things.... hmm. . maybe we can just adjust parameters...
i get it. we want out to just reflect active changes on self, not retrieving or modifying data operations... i think...
Lets list the operations we would like to imitate.
Displacing... .... yeah. I think we already solved the 'output' thing by leting orbs recall data or keys from others and just
storing it.
We want to be able to use this data collected and build new commands we can pipe werever we want. Bassically.
so lets say we have..

$
we can use money sign to reffer to the entity executing a command
#orb1/data/1>>$/data  Places line 1 on orb data casting this command
If we are on ~ stance and say '$' , it will return a list of access keys into the entity.
If we are on an orb stance and say '$', it will return a list of access keys into the orb.
$ always reffers to self

ONE MORE THING
we probably want to be able to cast commands in response to others . Or let one command success, allow for others in the
same line to be executed. .. So in this case, only if orb/out is returning a command casted and placing it on orb1/data, then
we keep casting next command and so on..
orb/out>>orb1/data , another comand, another one

We could build a chain of events being unlocked like this
command possible1 , poscom2 , poscom3 , poscom4
poscom5, poscom6, poscom7

So c on an orb would look like
[command1, command2, command3] , just like any script line.
We separate by ',' , and run comA on first command. if command is possible(returns positive tag), then we continue with the rest
so we place on c only the commands that were succesfully casted
if not, we simply ignore the rest of the line commands
orb/data/4 .. if line 4 doesnt exist, we just skip scB and continue
orb/imgf .. if imgf doesnt exist, we skip
orb/circlef/5  .. if frame 5 on circlef doesnt exist, we skip.. but also consume a beat

orb1/c>>orb2/c  execute the same command on orb2 .. cool

!!!!!!!!!!!!!!
ok so we have retrieve keys, command keys , and containers 
retrieve keys return a value to work with or modify the orb behavior by changing its value when on right side, ~/key , orb/key , orb/key>>?
command keys perform direct actions on orbs. all displace commands, all edit commands , com>>? 
 @, a command to soul seal.. these last two are a special case because they dont act '>>' on other keys or containers
edit commands like , 
containers have multiple lines. data holds any symbol and contains it. with no effect on orb.
script holds command lines ready to execute acording to L and run parameters
seal contains special lines to determine what aspects from orb are available
dsignat holds beat lines to be used by default on all entities orbs forms
We also have containers and keys inside a very specific container , data
orb/data/3/beats Returns lines of beats for line 3
orb/data/key is always a number to reffer to a line. Each line has its beats container.
//so we could put orb/script>>orb2/script... now how about that.. could get messy
//we should be able to asign orb1/data/1>>orb2/L . changing L directly affects what instruction line to execute next
SO we are sure we want lines with more than a single command? i think yes? we could limit this somehow, but we do need
to perform various operations in one sweep, beats need that. it feels clunky to limit commands to one per heartbeat for orb,
but it doesnt feel right either to be able to cast too many commands in a single line... ...
ok we could do something here.. what if we could run a command do something, and chain it to another orb that could run a command
in response on the same beat... that would be interesting. Because it would allow to perform multiple operations on a single event
but in a way that makes sense, each orb makes an effort to call the command. Its a limiter, but it also makes sense.. its actually
more versatile also. yeah its how i originally pictured it...
ok so after a command...we can type just one more command. Yup this sounds right
orb1/in>>orb2/data, orb1/data/1>>orb3/scB    So we have a number stored on data/1, its the line number we want to run next... but wait
... yeah we have a check problem . what if orb3 was already checked by the update loop.. hmmm. well it could be a trade off
reading in and out implies a special procedure to relocate the instruction into Orbs again to be executed after all other Orbs have
been updated
Ok 2 commands max per line for all commands sounds ok. We want to run the second command only when the first one could be executed
so comA needs to return something to let coma split know if it can cast the second one
A command can be executed when the target exist or the operation can be realized.

OK now we need to add some love to the interface. How about depicting the prompt mode. thats important
speed control important
and a way to clear up orbs(delete orbs)

currently working
@orbname , textform/orbname , +>>~/stance, orb1/data>>orb2/data

Locations
MSpX and Y are the center point from orbs perspective. orb x 0 is MSpX, orb y 0 is MSpY
all forms beats use their orb as refference beat x 0 is orbX beat y 0 is orbY.
... ok but cant we do this internally? we dont want to mess around with it too much it needs to be user friendly
We are using displace commands for orbs and entities, but we want to write directly on animation beats and states.
orb/data/1>>orb/circle/x   The number we are passing in should be added to the X of the orb. And if we are
retrieving,  orb/circle/x>>orb/data/1  , we should also substract the orb x to the number, we dont want to see the real
coordinates, we just want the refference value from the orb.


//VALERY
/* *  *
User starts inside the memory space of Valery. You can grow your space inside other entities space. Both have control of everything
when this happens.*
 *
 *
 * TYPING A DOT ON KEY MODE LETS YOU USE THE DOT IN THE SCREEN JUST CREATED TO CALL CURSOR MODE. AND YOU USE THE DOT TO MOVE THE
 * CENTER , SO COOL
 *
*/

Sinthax. maybe we could do DEL>>orb/text/1  DEL>>DEL , erase>> , kill>> , kl>>, kiss>> , deny>> , begone>> exile>> clear>>
supress>> rm>> delete>> DELETE>> !>> flash>> heatup>> freeze>> corrupt>> synch>> control>> silence>>

maybe orb/out could create a packet with {operation:'>>', result:'value on key'} This would allow for annalisis..?
the idea of out is getting cold. we can already retrieve all data we want using commands on left side..

Entity Combat
In sunya combat is..

2 entities can push back each other domains using memory orbs to avoid sharing space
Once entities share space, memories control are also shared. we can ofuscate atempts from other entities to control local orbs.
sealing visual aspects can conceal the orb prescense but are left more vulnerable to certain attacks.
Attacks can corrupt zones on the memory space. Once a certain treshold of msp area has
been corrupted, the entity needs to shrink back to clear up, otherwise it may become dificult to control orbs.
Orbs can also be directly corrrupted but also, they can use their forms to defend and also perform attacks.

so an entity can travelvtrough the void by surrounding itself with memories. memories can only be formed on msp. 
on the void, memories can only last for a time. many layers orbs can provide a vehicule for entity to move in void.

so what about memory space and limits. MSp Field . Entities Primordial Form
A space that never forgets how big was once so it retains its once achieved potential for as long as memory hardware retains its structure.
An MSp field is managed trough 2 polar signals. Grow, Shrink. An Entity will increase its capacity to proyect and give form to ideas
every time the field reaches a new size.
In time, users learn that the size of the MSp will have a key role on Combat. Because we sure have Combat in here, this is pretty much
a game because of it. We first want to learn the basics. Sunya is aiming to have a very  clean and highly complex strategy game which
invites us to really considerate our so called enemies, nothing else but the only other soul that is playing with you. There is
nothing but a massive Void like Ocean that drives everyone insane beyond the limits of our soul fields. It really is..
Time, Space... All is Telling You Something Nothing Is Ignored Time Space Into Nothing but White Noise Crushing Time Space Into Nothing but
White
Noise
Black
Noise
Void
Sea
A common game experience would be to take notice that, sometimes we need to wait a bit, sit for a while. Until we can keep growing again.
There are many things to do besides Just Keep Geting Stronger.



Learning Curve
First explain keys then explain how /data works!!

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$


All the Commands at Your Command

Entity commands:

@		Create a nameless orb in the memory space
@orbname	Create a named orb.
msgrow		Grow request for MSp
msshrink	Shrink request for MSp
loadimage	Loads an image into the browser for orbs to use.
loadaudio	Loads audio into browser for orbs to use.

Signals:
Signals are commands which require a target. Some signals can take numbers or use '/' to specify where the signal will work.



delete>>	Delete a target orb..?..it shouldnt be this easy..
rmline>>	Remove a target line on a container...?

left000>>		Displace left 
right000>>		Displace right
up000>>			Displace up
down000>> 		Displace down

forward000>>		Move towards the target
recede000>>		Move backwards
strifec000>>		Strife right in a circular pattern around target
strifecc000>>		Strife left in a circular pattern

textform>>		Awaken text aspect of an orb
circleform>>		Awaken circle aspect of an orb
rectangleform>>		Awaken rectangle aspect
...

Entity Keys:

~		Returns all data from the entity.
~/name		read. write. The name of the entity
~/orbs		read. All orbs names.
~/stance	read. write. Holds the name of the current stance.
~/dsignat	read. write. Holds default beats for all forms
~/in		read. The value of input box. Clears at every heartbeat
~/out		
~/inline
~/comline
~/limage	Holds all names of loaded image files on the browser.
~/laudio	Holds all names of loaded audio files on the browser
~/gspeed	read. write. The speed on grid mode displacement
~/wspeed	read. write. The speed on wheel mode displacement
~/x		read. Entity x coordinate. Screen center
~/y		read. Entity y coordinate
~/angle		read. Entity angle from focus point
~/dismode	read. write. toggle. Displacement mode 'grid' , 'wheel'
~/drag		read. write. All orbs and or entities that are currently being draged
~/keys

Orb Keys:

$		Returns all data from the orb currently on stance.
orbname		Returns all data from the named orb.
orb/name					read, write. Orb name
orb/gspeed					read, write. Grid speed
orb/wspeed					read, write. Wheel speed
orb/in						read, Input on orb				
orb/out
//orb/angle					read, orb angle
orb/cursor					read, write. 'circle', 'rectangle', 'text'. The form that will respond to Arrow keys
orb/drag

Orb text container:

orb/text						read, write. Returns and rewrite all text lines at once. free format
//orb/text/font
orb/text/cn						read, write. The number of the active line. selected line on text.
orb/text/1..2..3..4..last..current			read, write. Access lines by number or by keyword
orb/text/1..2..3..last..current/beats			read, write. Access all beats of line. Changes here are persistent
orb/text/1..2..last..current/1..2..last..current..cn	read, Returns beat of line by number or keyword. beat format.
orb/text/1..2..last..current/mirror			write, Creats a mirror image using data from location and a custom beat
							

Orb script container:

orb/script				read, write. Returns and rewrite all command lines at once. command format
orb/script/run				read , write, toggle. 'off' 'once' 'loop'
orb/script/cn				read, write. The number of the active line. current number
orb/script/1..2..3..4.. last..current	read, write. Access command lines on script container.

Visual beats containers general structure: circle, image, rectangle.....

orb/beatdir					read, write. Holds all beat formated lines only. Changes here are persistent.
orb/beatdir/run					read, write, toggle. 'off' 'once' 'loop'
orb/beatdir/cn					read, write,toggle. The number of the active beat line. current number
orb/beatdir/1..2..3..4.. last.. current 	read, write. Retrieve beat format line or write a beat into it to modify permanently
orb/beatdir/1..2..last..current/mirror		write. Create a mirror state using beat accessed data and a beat format text

orb/image					read, write. Holds all beat formated lines only. Changes here are persistent.
orb/image/file					read,write Image buffer. file name to synch orb beats with the image. current image file name.
orb/image/run					read, write, toggle. 'off' 'once' 'loop'
orb/image/cn					read, write,toggle. The number of the active beat line. current number
orb/image/1..2..3..4.. last.. current 		read, write. Retrieve beat format line or write a beat into it to modify permanently
orb/image/1..2..last..current/mirror		write. Create a mirror state using beat accessed data and a beat format text
... maybe images dont need mirror since all image proyections are ilusory and dont have physics...

Audio containers. oscillator

orb/osc					read,write all oscillators at once. 
orb/osc/run				read,write
orb/osc/cn				read,write
orb/osc/1..2..last..current		read,write
orb/osc/1..2../gain			read,write
orb/osc/1..2../freq

..incomplete


$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
command
command>>target , com>>target/specify
cont/key>>cont , cont/key>>cont/key
cont/key/sub>>cont , cont/key/sub>>cont/key/sub , 
cont/key==cont/key
#literal>>cont , #literal>>cont/key , #literal>>cont/key/sub


focus>>target Allows an entity or orb to move around a specified target using strifec, strifecc , advance and recede

We want a command to supress all empty lines on a text and just leave lines with text

Thinking about totally yoinking the orb/in thing. It does feel redundant at this point.
Lets recapitulate what we can do actually with the current script system
Ok so we keep entity in and out. Ein is simply input prompt into '~' . i think. But Eout... we want to Eout to give us
something we can work with. Maybe a result from the executed command... maybe the command itself.. am not sure
.. Ok once again. a twist. orb/in and orb/out is working perfectly and its good


I know its a bit of a sudden .. But could you please do something for me real quick?
Could you look into the center of the browser screen? Do you se a point there? Its one pixel!
That Pixel Right There...
That is Your Pixel
But you cant move it around just yet! You need to create the possibility for it to move around first!
Would you like to expand your Possibility Field? There is a command to do just that! Memory Space Grow..
Just Press Enter once and type right in this very simple command: 
msgrow
...
Well thats not really much but its One More Pixel than before at least!
What if we could asign this command into a key on your Computer Keyboard... Maybe we could grow our field faster by simply
pressing this key for a while..? How about using that key which i already prepared for you! Press g! And let me know when
you are tired of it! Hahaha
Well now you can try moving your pixel with Arrows... And how about changing the speed? We could use a command to do that!
#5>>~/gspeed
Why a command and not just a button you might ask... Well first comes the Noetic, then comes geometry of the possibility!
Commands are instructions! Buttons are just calling Commands! We can asign Commands into any Button! We can create Buttons using Commands!
The possibilities are Endless! Haha
... a command to create a Memory Orb, would you like to try to do that? Just type in:
@My First Memory Orb In Sunya ... Or you can call it whatever you want! You can call it @Joni ! or @Jeni ! or @!!!  Just be sure to type
in this very fancy symbol from the 90's here  '@' I am not sure what even means, But its very neat so i decided to include it in the program!
A memory Orb is just a structure to hold instructions and data. We can awaken Aspects into this orb You just created... Lets open up
the orb possibilities into a new Aspect, just type in the command:
textform>>MyOrbName
Would you like to take control of your orb so we can move it around? Type in a command to change your Stance
#MyOrbName>>~/stance
.. since this orb now has text aspect activated, we can write text directly into it by pressing Enter once, and then pressing
Enter again to call for the input line prompt. We can write a line here and press Enter to store this line into the Orb
These lines can be instructions. So we can store in here instructions for orbs to perform for us!


Some orbs may try to prevent you from annalyzing other orbs ..

OKOK COMBAT IDEA
Entering into a special memory orb that slows down all commands cues. All commands casted by other orbs inside this orb MSp
enter a wait cue . .. hold that thought

OK SO another combat idea would be ..... !!!!!!!!11 Yes it makes sense to force entities to use many orbs at the same time to create
the most powerful effects. ..
An entity screen can freely move in its domain but memories cannot move like that without a cost.
the orb speed value consumes an entity memory capacity.
Every time an orb casts a command, it consumes memory cap.
Every text line an orb hold consumes memory cap.
Script lines consume memory cap
Visual animations frames..
Tone lines..
We add up all lengths from containers to get the total. Sunya checks slowly this, not at every heartbeat .. ?
.. what if keeping track of this is a bit convoluted? .. consider simplifying this
Actions have a cost. Some actions have more or less cost. High cost actions leave the entity in a vulnerable state.
The point is to keep stamina/memory/cap always high enough to prevent intense attacks. 

A command to add a string of words?...

OKSO we want to say, orb/x , and this would be the same as orb/circle/x?
We want `freedom to place images independently from the circle aspect x of the same orb..
We want circles and rects to act like physical sensors, their area can be used to scan or send signals to other orbs.
So we probly only want to restrict these 2 in their movement capacities, but drawing images should not have restrictions because
images are only there to complement the mechanics of the interactions between circles and rects on the screen... text on the screen
should also need not to be restricted in movement.
this is about COMBAT
ANOTHER thing is, if we can freely move entity screen then it follows that we can create memories at any place instantly while inside 
the entity msp. do we want this? .. the idea was using circle or rect aspects to produce effects on other orbs..... but am thinking
.. how about using a diferent aproach?..
signals. .. so forms can scan. scan takes an orb name so we can use the name to send signals into the orb in area. all signals
can be filtered by the target orb on ALOrbs phase
If an orb was previously prepared to react to a specific signal, then it would read something like
$/signal>>#deny  , $/signal>>#accept 
There are types of signals. some signals create an effect to act upon the target orb.command request. creq
others request specific data from the orb. data request. dreq
Orbs use a command line to process a signal at a time. many signals can be sent to the same target at once. To prevent an orb
being saturated by signals and loose control, orbs can build defenses to prevent it. 

OK so. a vision. Two entities find each other. As long as all their memories are in guard, entities cannot control each others
memories, but since all memories are busy preventing signals from the other entity, no further action can be taken without
leting the guard down.. 

done already
We want to be able to copy instructions into many orbs at the same time. We want multioperations at once ehh. we good
WE wantt to be able to erase an orb fast. done
And to change names.. hm.. yeah we want this. done

So also we want to be able to write a process for an orb to be waiting for an orb with a specific name to activate and make
the named orb do something
We can instruct user to create a specifically named orb so the program takes care of it.
Keeper/text>>Zac/script,delete>>$
This line will keep asking for Keeper and Zac, if none exist, line doesnt do anything. When both exist, we perform the operation,
and then we self delete. Interesting.

done already
We want to be able to push a line of text into a specific place on a text. #something>>orb/text/5  . So if the line doesnt exist,
then we create empty lines until it reaches target line... thoughts? We also need a command to supress a line and its placeholder,
effectively spliting the whole dataline. done

We need repeat keys and not repeat option. button customization. . later

Ok lets check out prompt feedback. We want to modularize Enter into a command because  phones. A button or gesture to call com prompt
and in prompt
We want a visual feedback to know what prompt is on focus
we want a command to print all shorts/buttons

Thinking about strife, focus, and displacements.
the way it works. . #target>>orb/focus . When a targetis on focus, displace commands from the orb will now use wheel values instead of
grid. strifeleft for left, striferight for right , arrow up becomes advance, arrow down becomes recede

SO we could limit operations by puting a price to actions. displacing signals will have a different cost depending on the speed of displace


Lets think about images for a moment. What if we just have a state ready to go instead of one single state being updated everyheartbeat
... hmm

Make scripts to work with lines. copyprompt and in commands. speed displacements. wheel

What really means to erase a line. 

Lets think about audio. We want a sinthax. Audio uses ms , not heartbeats.
gain,1.2,freq,345,duration,1234,type,'sine', 
If we call repeat run on a line it will simply run the tone as long as its on repeat. so we can just asign repeat and call different lines
to use it like an instrument
WWould be fun to make one oscilator in one line, then control oscilator callings by calling specific lines, we could even play it like
an instrument. We can create melodies by asigning timers are well, but we cant play multiple tones, we need one orb for each tone. yup
sounds ok lol 


I feel blessed now. Am not so sure as to 'how to call it'..., 	but is this flow state of kinda intuitively finding the answer to a problem
Just by 	keep trying to simplify things, take distance and see other possible ways to solve a problem.
			It feels absolutely envigorating,
it feels like flying.
In this realm of electric harmony . I cannot harm others with my mistakes. 
I want the flow state. 		I dont want to loose myself in errors. I dont want you 		to drown in the sea of my failure.
Take distance.	A door will open.   

so a clean annalizer. first we divide using '>>' . This narrows the thing quite a bit. So we will focus only on commands with '>>'
RS retrieving side left , CS container side right ,
read only keys and container, read and write keys and containers
!!!!!!!!!!!
so what does really stancE mechanic add on comman synthax. a lot of messyness .for sure. but is it worth?
we could completely remove the stance mechanic. it just doesnt make sense anymore.. we could just say
orb/con/key>>orb/con/key . If we wanted to reffer to the orb executing we could say . orb/con/key>>$/con/key
This is clean and consistent. it severely simplifies sinthax for execution. what about input
Input can simply be picked up by orbs listenning? maybe a list can take care of that. text aspect has an array with all entities
being listened. simple. using Elis now



So here is a thing. Having no physical form on a memory, prevents it from moving, so it will stay in place invisible. By default
in the center of the MSp. Having a visual form allows orbs to potentially evade attacks, but its more exepnsive for the entity memory
So its a trade off.

instead of sel. fal . form active line . alif . b . bl. bln, bn

!!!!
to highlight, we could simply ask for the current beat on a container at every loop and paint the correponding line.
What if we wanted to create specifc changes on states to last a few beats. we could change the state directly with commands.
this would offer a lot of possibilities.
data line 1 in orb1 could have a beat writen like this
[r,200,g,200,b,230]
so now we just do:
orb1/data/1>>orb2/circle/current
So we use /current like this to access the current beating line. And we could dump a beat
formatted line on it to change it temporarily for one heartbeat duration !!!!! this idea solves a lot of things.
.. for consistency, we should only use the beats directory for permanent changes .
so when we feed any line beat directly with a beat formated line, then its a temporary change.. data container however...
lines beats are the problem. If we say [r..,g..b..]>>orb2/data/current , how to tell if we want to asign the state into the beat
line or we simply want to write down a beat formated line into the data text..... hmmmmmm okokok
so maybe to write down new data input we say orb1/data/3>>orb2/in , and this automatically adds the data into the /current line
as data and not a beat... this feels more consistent
So we can safely treat /data/1..2..3..last..current exactly as we treat other forms containers when passing on beats.
So since  current returns the currently selected or active line, then how can we retrieve just the number of it?
orb/data/sel Could return just the number of the current line.. so now we could have and orb1
1
[r..,g..,b..]
and say
orb1/data/1>>orb2/data/sel  to change the active line.. and then  ,orb1/data/2>>orb/data/current ... this looks fine
So we have a key to reffer to the active line itself, and another key to reffer to the number of the active line. that solves it
!!!!!!!!!!!!!!!.. however.... when we retrieve orb/data/3..last..current , we dont want the beat, we want the data content..
Maybe we need orb/text after all.. or we could simply add /data at the end like
orb/text/1..2..3..last..current/data  this is clean?
We could say orb/text/1/2 to access beat 2 on line 1 temporary state..
And when we want to change permanent beats on a line we say orb/text/3/beats
orb/text/1/sel  .. the active line on line 1 beats.. orb/text/1/current returns the literal active beat on line 1...
so orb/text should simply return Literal text, because we cant just return all beats of all lines thats not practical.


orb/beatdir/1..2..3..last..current
All beat directories return their lines using these keys. and the lines are beat formated

orb/script directory holds command lines. literal commands. but it also can be
accessed like this
orb/script/1..2..3..last..current

We use orb/beatdir/run to manage running operations

We can also retrieve all beats at once
orb/beatdir

We could use delete>> to delete lines and orbs? .. Maybe we cna consider the delete commands as part of the mechanics in combat
.. the idea of instantly wiping out orbs out of existance has not much appealing. I would like to see orbs peeled apart slowly
and Experience damage.
Maybe orbs can be corrupted and getting rid of their structure could feel more like treating a wound in the entity
Perhaps we can choose to sacrifice a wounded orb to liberate memory, but all desitions in combat have a cost.
. we are going to need to build a fast remove command for the time we finish working on the system






//we want to return a multiliner in an array with all line beats. so we probly need a function to do this. turn a beat into a line
//we can work with and put back into a beat container for multi and solo cases. RSout becomes an array of beats. Do we transform here
//or when we put on container? we can just take an array and say .toString(), it will transform into a single line.
//so we can loop the beats, and get all beats as lines, and push them into RSout. so when we place these beat lines on a proper container,
//in that moment, we turn them back into real arrays to beatUp
//details.
//thing is. when we turn to string, numbers become strings too.. so we need a little function to take a string beat, and
//transform it into a proper array beat

//clean command feedback with backspace
//Fire and Ice waves really are Force expressions driven by opposite polarities. Fire represents the desire to expand and explore
//while Ice represents our desire to stablish and explore inwardly.
//Fire Waves are stopped and absorbed when they encounter a Husk with many Ice layers.
//Fire waves can absorb other fire waves in order to becomes faster and more intense.
//Orbs inside a Husk are prevented from vanishing. Fire and Ice have no effect on memories inside a Husk.
//Fire over an Orb in the void. . maybe orbs can attach to Fire waves and begin traveling along with Entities.
//Ice over an Orb in the void.. If an entity casts Ice while on Orb stance maybe we could link memories around? because it makes
//sense to be able to move around a memory when its inside a Husk perhaps, but in the void, we can drag them using Fire too..

//We could also use Ice to have an effect on memories. Fire would also have an oposite effect on memories....
//Thinking about Ancient Husks like cities for "pacifist" Memories. However i dont see how the script system would work here
//.. so maybe vessels should be able to get inside Husks.. or not... thats kinda the point.
//I think scripts should be reserved for vessels...
//Maybe Husks could be guarded by Vessels. Thats an interesting idea.

make input prompt a command, Enter 2 times is weird

/*
Also we want to be able to remove lines. rml .. sounds right. casting 'rml' on an orb stance will atempt to remove o.txtLi[o.txtB-1]
this is convenient enough, pretty straightforward. We could also do rml>>orb/txt/1...
but how about a universal destroy command. it can delete lines , orbs.. and maybe atempt to reduce a specific entity parameter... from MSp
also.. hmmmmm !!!!!! delete>>orb , delete>>entity , ... this command would send a kill signal somewhere... but the thing is
Now orbs, lines and other elements that can be 'attacked' may present defenses. The most straightforward defense would be to redirect
the signal to another less important part of the system, kinda like a reflecting wall. But eventually , the signal would erosionate the
net of the entity.
Another way to prevent kill signals from destroying a memory domain could be barriers kinda like hit points? But these hitpoints
could work like pressure.. if too many signals are atempted into a single memory, the pressure could be enough the destroy the barrier
and erase the target. another idea? maybe some memories can be chained together so they can only be erased when all chained memories
are attacked at the same time, ... interesting, also chains could even be scripted to replace their parts with different memories.
Maybe we want some commands to asign certain characteristics to a memory. shield23>>orb/text/1 or link4>>orb
This is interesting
So an orb listen to a specific orb for a specific command output which can be used to counter or contain the effect.... !!!!!!!!!!!!!!!!
So an orb listenning in this way, it cant do anything else . Its script needs to have a single line so it can be repeated at every
heartbeat so when the effect we want to contain is executed, we wont miss it. But we could also configue many orbs to listen 
at specific beats in sequence, in this way, many orbs could react differently to a same command, and we distribute the attention 
level required to not missing a beat. very cool i like where this is going. ok goodnight friend. cyu tomorow. you are the best. we
are the best. we kick ass. cool and good

So reacting to orbs in and out is redundant, we can react to changes requested from orbs already, however reacting to Ein and Eout
is very simple since we check for Ein and Eout(Entry?) at the beggining of the heartbeat anyway

ok so now we want to be able to move many orbs at once, make it happen

*/

//if we wanted to generalize the output system , we d have to return what exactly, the raw command? the command output?.. sounds
//convoluted..
//idea. we could monitor displacements and speed changes on target only when orbs are in synch . 
//just use target stats and copy them into the follower orb or ent displacement stats......?

//If we had to actively write a one liner instruction to constantly follow an orb or an entity, then script potential would be drained
//.. so it would make sense to just use a command to synch or anchor orbs position in refference to a specified target..
//.. more so, we could move in circle, front and back in refference to this target or simply copy transfer its x y coordinates
//at every heartbeat. so its an anchor/focus mode that accepts one target orb at a time. ok this is cool but how to implement
//Its not an instruction, but a key value that needs to check on everyheartbeat for the displacement activity of the target anchored
//So in this system, the "target" would keep track of all orbs or ents it wants to drag with itself
//ok so we have orb/drag . a list of targets to demand to reflect displacement activity. The orb will ask to drag , and the asked will
//move or not depending on permissions... or anchor state?
//drag can be used in combat... all combat commands are active and called by caster but they need to have
//and we have /focus, /anchor . a single target to use as wheel displacement center.
//So this simplifies things. Now that we have active commands that create effects on target orbs, we just run them and ask if target
//orb is susceptible to the effect of the command. no need to listen to outputs anymore
//SO when we cast drag or delete , the active caster ask if the target orb is vulnerable or has permission before creating the effect
//So drag and delete .. might be similar to deleteline.. maybe the same delete can just be run on a line. commands that act on other
//orbs or entities. once cast, the target needs a chance to prevent the command to work on it.....
			//
//okokoan idea idea... what if we just asign this parameter into orbs. inertia . a value on inertia spends memory points to
//prevent operations on the orb. in order to overcome inertia, many control signals must be casted at once... ok inertia interesting
//BUt maybe we only want this inertia system to be active when against other entities..? for now lets just focus on creating
//all the commands we need and want without restrictions.

//we could write down targets on a text and simply say orb/text/1 to use that line , to find the target. This is brilliant. And
//consistent with the overall synthax. what if we say disup>>#name of target. That would be insane. So signals..
			//
//ok lets improve the displacements commands. now we want to be able to optionally asign a speed in the command line itself if we want
//we need to consider sinthax . how about  up:6>>orb/circle  . we could use ':' .. we could use that old techinique 
//just grab the first letters in the line like this . if RS[0] first two symbols are 'up' , then check for a number at the end
			//
//and here , we could just use Drag list to also cast displacement on all targets on list... or maybe, we could
//send a displacement signal to be read later.. because we l also need to test how the signal works against the
//target. .. and ALOrbs is the right instance to check for that
//HEY a solution fo the in out orb dilema. Why not just use a whole different array and check for it after heartbeat loop..
//.. geez that is far much better than messing around by pushing signal into the Orbs array itself, just use a different array!!!
//once again. this changes everything. oh jeez. and its working. good jobking
//ok lets focus again on in and out. Let drag mechanic have a moment.. ok in and out working like a boss . lets focus back into drag
//mechanic again.. ok so we should be able to force displacements using signals but also, we want the displacement synch system
//ok this Drag working. We could rewrite this a bit tho ... later
//so maybe Entities can drag... while memories can only send signals?

so am thingking circle form may have specific options, rectangles may have others . 
..maybe all orbs need circle form.. we do want orbs to have a sense of physicality so entities can act but also
take damage trough orbs mechanics

.. beat changes not listenning.. check that out
also $/x commands not returning RSout

//so what really should user be able to learn about position. the screen can be permasynched with Ecen, but Ecen 0 is the memory space
//0.. isnt it. Memory space position takes main canvas values..

//so these coordinates are the actual center of screen. The entity screen center. Ecen. we probly want these to also be read only. no.
//but we could do orb/x>>~/x<>orb/y>>~/y . Tha could be interesting. Because we can make orbs trace a specific activity and the just hook
//into that orb. lets do that. We need an instruction to translate to the location of the orb.... wait no. We just want the difference
//between ent x and orb x , then ent y and orb y. This difference will tell us how we need to translate to match orb location. !!
	//so all we need to do is build a function to do the math now, then implement the function here
		//if oX>eX , displace to the right(left) a number of times equal to the diff between oX-eX
		//if oX<eX, displace to the left(right) ... = diff bettween  .. ok  math is good but. we l do this differently
// ~/x expects a coordinate number, we want the explicit number of x in refference to the MSp center so
//x negatives are located to the left and positives to the right
//y negatives are located up and positives are located down .. from MSp center.
//OK so the most pragmatic thing to do is this
//ctx0.translate(eX,eY);
//ctx0.translate(-(targetX),(-targetY));
//cant believe it works perfectly. we can now simply asign x into entity so it goes there. Watch out for falling outside of MSp
//.. what happens when we end up outside of MSp?

//okoko am having a achange of heart here. Maybe we dont want an MSp 'interface' we could simply say ~/msp and this would return
//the msp current value. we could say ~/mspx  , mspy  , mspradius . simple.
			//
//so we need a MSpace command to retrieve and work with msp data. msgrow and msshrink mechanics are ok i guess, one command
//at a time. Maybe we can just return all msp data at once? kinda like with skeys
//MSp cannot be asigned a new x or y the same way we do with eX and eY, but we probably want to learn about MSp location in refference
//with the void canvas center X0 Y0. we want the size of the space in radius, and its memory capacity? We might start thinking about
//memory limitations btw. We said growing MSp would grant a new max memory orb capacity as long as the size reaches a new value. MSp
//can shrink back but the entity will still be able to control the same number of orbs it can control while MSp radius was bigger.
//I want the grow system to be permanent. User is relieved from the fear of losing its progress.
//but what does msp on its own return? maybe dirs..  ~/msp/ .. hm.. We need to use real parameters here . Maybe we could print
//all data on lines at once instead . we can simply access what we need

//follow is kinda deprecated .. not sure just leave as is for now... ok follow sounds interesting because its a fast and easy way
//to hook memories positions without having to worry about writing the logic . . however this might be an obsolete way of seeing it
//kinda like what happened when i tried to update the .type command. Turns out we dont really need that since we can now use
//inline and comline...
//OK but now that i ve been playing around, i noticed the flow in creating interfaces, and its really a bless to be able to simply
//hook orbs into the entity center like this, or into other orbs. Its just very intuitive and satisfying to be able to hook like this
//.. i think we want to implement this hook follow command so the displacements mehcanics are taken care by the system itself
//i can picture many instancesw were we l be hooking orbs to each other , it doesnt make sense to having to worry about all the little
//commands required to atach orbs into other orbs arrangements. Yeah i think we really want this follow command
//so we say:  orb1/name>>orb2/follow  . we can also say: orb1/name>>~/follow 
//follow	If it holds an orb or entity name, it will follow and synch its position with it.
//so how it works... an idea. Everytime we change this follow box value, we store how x and y far away the follower is from the followed
			//
//..or.. everytime the followed displaces, it produces an output. followers could evaluate followed output and use it on themselves
//to displace just like the followed.. but in that case.. isnt it more simple to just evaluate output..

//TYPE
//.type is a special command that only takes one parameter which is a string that can contain "." and ":" without having an effect
//on the instruction. .type:a string to appear on input and instant focus
//This command is useful to create specific shortkeys
//This commands should probly be available always. !!!!!!!!!!
//PEAK! This command was rally peak ngl. But now a lot has changed. We have com prompt  and in prompt
//We still want to able to just Press a key, and link a couple of commands. we want to grab a current line selected on a text,
//and pass it into the prompt, to modify it, and maybe place it somewhere else. We also want to be able to just type in a previous
//text on any prompt..? But thats kinda strange because we could now simply write something to be copied and keep working on..
//okokokokok maybe treat prompts as containers... in .. and out... kinda like .... let me just.. ... ... what really is in and out?!!!!!!!
// ~/inline	read. write. The value of chat_in on input prompt
// ~/comline	read. write. The value of chat_in on command prompt
//so we could say something like: $/text/current>>~/comline .. or ~/inline>>$/text/3? thats a bit weird... no not really. an orb
//could listen to this value and work with it in real time. PEAK 

//we shouldnt be able to change position directly .. for now at least. When we ask for orb/x , what refference do we take?
//MSp? but memories can exist beyond MSp right? .. if a memory is out of MSp... how do we locate it? ..hmm . Maybe we can just
//keep monitoring its position but not making it responsive to the entity commands... but we dont want to move the orb out of
//range when we move the entity.. so it needs to be independant from the entity location.. so maybe orbs just need to use real
//coordinates.. hmm.. yeah like everything else, its just that , when we retrieve an orb coordinates, we want a number with which
//we can work with. We cant work with its real values, we need to have a refference. MSp makes sense to be this refference, orbs
//cant be commanded beyond MSp radius actually, so yeah

//idea. we could add a defense layer simply by typing in @orbname many times? defense layers... more like inertia layers..
//inertia layers prevent orbs from receiving and being affected by any signal. displace, delete.. in order to overcome inertia
//a signal must be sent multiple times ? saturating an orb with multiple signals creates a paralizing effect?
//the number of signals an entity can produce per heartbeat will depend on its memory counter. Each memory orb can send a specific
//signal once. So in order to produce the same signal many times at once in a single heartbeat we need to instruct multiple orbs to
//execute the same command at once.

//so when we request orbs position, we take MSp as refference. that makes sense since orbs can only be sustained by memory space,
//we want this rule. so how about accessing MSpace data? What if we want to know MSpace x and y, this coordinate should take the main
//canvas itself as refference
//.. so am thinking orbs should not be able to move so fast as to just take any coordinate value and travel there in an instant like
//entity eye does..

when we drag, we need to be able to specify what aspect we want to affect. done
and it makes sense to be able to do orb/aspect as target for command signals in general

ok ok ok we are doing great! now we need to also include instructions to manipulate the beats. done


Ok i think i figured out combat.
We want to be able to create rules when entities are inside other entities. We
can choose to use the rules to play... This solves everything
2 entities can enter a common third entity which is applying the rules. So now
when the two entity guests try do to overpowered commands, the third entity
englobing prevents those actions.
This is fine.
Now we need the last mechanic. To be able to create rules easily. Create conditions on entities when inside
an arbiter entity. 
With this comes modularizing entities. We need the entity to be an object. Online mode requires it.
Maybe ai entities can be abstracted somehow .. 

Ok remember when we could load text to recall orbs? we need to do that with data lines now. So just load a script right away
or lines beats, or tone lines, or circle or image beats. or keys...
:textfilename>>target/container
heh.. ok lets do something sneaky. what if we just take a text and use ' ' as separators to split into lines..
lol it works. like a charm  baby

ok now we need to make buttons great again. we probly want to be able to contrl auto repeat. just make buttons or keys have a parameter
to allow repeat. this is more convenient
also, we want to be able to say orb , and just dump all data about it in real time everytime. active lines higlighted. just like that
easy

what about focus

hey maybe we could actually use mirror on images for editing animations..

man this angle bs is just lame. i need to rewatch that radu vid because getTheta is not giving useful radius values for somse reason
i think i l just bury this.

ANYway. I just got an idea. How about rects . Rectangles are good. The screen is a rectangle. A rect area that makes all orbs push
into a specific direction always.

So we move around orbs... Orbs need to be really important, whats really important are scripts. We want to be able to move around scripts
too. 
ok lets work on images after rects. . later

We need to adresss the comline feedback situation

. . some clear goals 
we should be able to say delete>>orb/text/1 and leave this on an orb as an instruction
create>>orb/text/current<>+>>orb/text/cn  to create orbs using a text names
and maybe $ should just reffer to the current stance instead of the orb calling the command,,? or maybe % 
SO how about $/x .. we need a way to reffer to an orb location.. using its aspect maybe? orb/text/x , orb/circle/x
so we can say orb/text/x>>~/x<>orb/text/y>>~/y
also .. what about delete>>orb/text/1.. we should be able to use text lines as targets for signals
the idea of maging form be able to send signals..
when we say ~/orbs , we dont want to see '~' in there. done

signal()target

okokok i think '==' changes aeverything and i still havent realized it.
because now we can simply say
orb/out==#left/$<>left/$
so /out should only output command signals when casted by the entity or orb since retrieve commands can simply be tracked by asking
the containers directly so yeah

.. script ideas

Editor Scripts
a script to remove all orbs on a specific text
a script to show all orbs always , follows entity around, darkened when not selected, highlight selected line and actually make
orb in line become the stance and move the entity screen to center of selected orb. we can then just select a line to change stance
a script to show entity stats always
a script to show stance stats always

a script to create an orb with random instructions running. this might be fun

so an orb area could send signals to all orbs inside. this is an interesting idea.
ANd a thought. . WHat about just not even using this idea of areas..
We want visuals to reflect what happens with the datalines, we go a step backwards and more if we condition instructions to areas and
visual conditions , data lines should dictate what can be done anytime to prevent another specific instruction
A timeline... we should be able to see the timeline of instructions.
.. and yes we do need a drawing app.... but a really cool and simple one. not for drawing , but for connecting things with lines

ok big fucking problem its the backwards loop thing scripts or texts are
backwards omdfgomfg omfgomfgomfgomgf this is so fucking lame. ok itscorrected


I will not forget this feeling. I will carry this memory in my heart with every step i
take , and every beat ashore.
I will follow , and i will always try to find the way into the
place that is waiting for us.
I promise , i wont let it fade, the most beautiful feeling in my life..
Dont leave you behind. Dont leave me behind. Dont leave anyone behind again.
Until all that exists becomes the love that you see
Because the silence you so naturally float towards to is my infinity,
and i am in love with everything that exists in your prescence.

Allow sound?
Void background noise gently pressing in. Colors as well.
A giant circle coming towards the center clearing up the noise. Covering now the whole screen. Noise is gone.
A point in the middle. Its the user entity screen center.
We start inside another entity. This first encounter with another entity will help user to understand some basic commands.

In Sunya we dont have experience points. We just have experience lol
We can see lots of numbers that will start to grow the more you learn stuff to cease your anxiety levels, but its knowledge what will really
strengthen you.
If you already know about videogames or have images or sound or text lines that could help you represent your creations, Sunya
can recognize your images and ideas and use them to build a more accurate depiction of your prescence.
This is why we dont call you 'User', for Sunya, and in the eyes of
Kaozzai, you are an 'entity' that comes from its own realm and brings with it its own experience into the void sea. For this, Kaozzai
is honoured and grateful, but will not show it.


..so maybe orbs should be able to travel beyond MSp... but they deteriorate in time and eventually get corrupted.

and o.o could simply give a hint of what command the orb is trying to execute. This might be useful for third entity games
to set limitations on their MSp
and maybe , aspects need to be unsealed in order to be able to be deleted. So a defensive strat would be to unseal aspects
momentarily and then seal them back again before they are attacked

to the third entity can listen to output and determine if the operation is permited in its MSp. Eout and o.o should then return
the command and the target signal[0] and signal[1].
target/in==#something<>#once>>orb/script/run
# can be used to create any literal value but there is only one symbol that cannot be written more than once on the command, <> .  
the '<>' symbol can only be used once per line , even when we do a multiliner , we cant put more than 1 '<>' per line.

ok , so image x y 0 needs to be orb circle. Because when we move orb circle position, image needs to perform around this point...
i just noticed. this is important
OK also when no beats, orb simply sets itself run off , how about that
AND yeah i think it makes sense to have Elid Ecen and even MSp roles to be performed by orbs. This is even more convenient for multiple
entities dynamics


... ok we need to create an orb to do MSp job now... clear up and update displacements commands..
..MSp limits are too arbitrary. not likey.
How about .. having one simple condition to move the entity center around. is being inside a memory form?.. maybe the other way around..
How about entity being able to freely displace.. but memories forms able to prevent or control an entity displacement..? thats better
Makes more sense too. An entity can create memories to stop other memories from impeding the entity displacement and so on..
The idea of MSp also serves to anchor coordinates numbers. Because we want to have a refference when we define coordinates
on the beats visual aspects in orbs.. but.. ok what if entity is not restrained by its own msp.. and so.. when an orb is created
.. maybe circle aspect can just have the current entity position , and so are rectangles, but what about images. We want to be able
to move around the center of the image animation, also the center of audio orbs.. so maybe image and audio aspects need circle or rect
aspects previously unsealed ..not a fan of that.
we could just asign an arbitrary center as well...
so image and audio can be asigned a focus point, and we can also make an orb circle or rect aspect its focus point! i like that.
orb/image/centerx , centery
orb/oscillator/centerx , centery
.. so a script could say: ~/x==

ok now we need to create interactions. so the most convenient way would be by annalyzing o.o . orb output.
+100>>o1/circle/1/x .. this instruction needs to generate an output on the caster that can be annalyzed by a listener instruction
if casted on the same heartbeat , o1/out>>listener/text . the result needs to be expressed in a multiliner.
If an aspect changes location, output should express the new location, what signal got it there, and what orb. We check the state of the
aspect that concerns us, not the beat itself. 
A listener orb needs to be able to use the output data produce an instruction to
copy its behavior and execute on a different target,
cancel its effect, effectively blocking the effect of the instruction or
modify the instruction using a different text line and proyect it somewhere else as the listener see fit.
Once this mechanisms are ready we wont need drag. Orbs will have an efective medium to comunicate and create timed dynamics.
MSp dont ring many bells now either
.. and its done. output signal works fine.

ok so if we clear all beats on a line, the line will still exist , but it wont be visible
If circle has no beats, it wont be visible but still exist..


after that... we probably need to modularize the whole entity structure....
.. and then... make some image editor scripts... maybe some sound editing
scripts to play around with oscillators... and by then we should start working
on Kaozzai and game introduction..... omg so much work

..aaand am not even using MSp now..
